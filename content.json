[{"title":"CTFrame.h学习","date":"2017-03-02T03:52:19.000Z","path":"2017/03/02/CTFrame学习/","text":"CTFrame 相当于布局控制文件。控制文本的整体绘制。 我们从三个方面来看这个类 1. frame 访问函数123void CTFrameDraw(CTFrameRef frame,CGContextRef context )` 将文本呈现在屏幕上 123void CTFrameGetLineOrigins(CTFrameRef frame,CFRange range,CGPoint origins[] )获取range范围内frame每行的起点 range 需要解释下 range.location 是 从第几个开始返回point range.len 是返回几个，要是0就默认返回都最后一个。要是range 的location + len 大于CTLine的数量，所有的origins 都会是（0，0） 获取的坐标点是 coretext坐标系中的坐标 1234567CFArrayRef CTFrameGetLines(CTFrameRef frame )获取frame所有线的数组，frame是由CTLine组成的 NSArray * array = (__bridge NSArray * )CTFrameGetLines(frame); NSLog(@&quot;frame lines %@&quot;,array); 123CFDictionaryRef __nullable CTFrameGetFrameAttributes(CTFrameRef frame )获取修身frame的相关属性 123CGPathRef CTFrameGetPath(CTFrameRef frame )获取frame绘制的路径不包括剪切路径 1234567CFRange CTFrameGetVisibleStringRange(CTFrameRef frame ) 获取frame 能看见的，绘制在屏幕上的string 的range范围CFRange CTFrameGetStringRange(CTFrameRef frame )获取frame 字符串的范围(包括不可见的) 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142- (void)drawRect:(CGRect)rect &#123; CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetTextMatrix(context , CGAffineTransformIdentity); CGContextTranslateCTM(context , 0 ,self.bounds.size.height); CGContextScaleCTM(context, 1.0 ,-1.0); NSMutableAttributedString *mabstring = [[NSMutableAttributedString alloc]initWithString:@&quot;富文本学习/慢慢来吧。不是一朝一夕之功。ok \\n ok ok&quot;]; CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)mabstring); CGMutablePathRef Path = CGPathCreateMutable(); CGPathAddRect(Path, NULL ,CGRectMake(10 , 0 ,self.bounds.size.width-10 , self.bounds.size.height-640)); CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), Path, NULL); ///frame 相关访问函数 相当于布局控制器。我们能获取布局控制器相关参数 CTFrameDraw(frame,context); NSArray * array = (__bridge NSArray * )CTFrameGetLines(frame); NSLog(@&quot;frame lines %@&quot;,array); NSInteger count = CFArrayGetCount((__bridge CFArrayRef)array); CGPoint origins[count] ; ///range 需要解释下 range.location 是 从第几个开始返回point range.len 是返回几个，要是0就默认返回都最后一个。要是range 的location + len 大于CTLine的数量，所有的origins 都会是（0，0） 获取的坐标点是 coretext坐标系中的坐标 CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), origins); for (int i =0; i&lt;count; i++) &#123; NSLog(@&quot;frame origins %f %f&quot;,origins[i].x,origins[i].y); &#125; NSDictionary * dic = (__bridge NSDictionary *) CTFrameGetFrameAttributes(frame); NSLog(@&quot;frame att %@&quot;,dic); CGPathRef path = CTFrameGetPath(frame); NSLog(@&quot;frame path %@&quot;,path); CFRange range = CTFrameGetVisibleStringRange(frame); NSLog(@&quot;frame visibleString Range %ld %ld&quot;,range.location,range.length); range = CTFrameGetStringRange(frame); NSLog(@&quot;frame String Range %ld %ld&quot;,range.location,range.length); CGPathRelease(Path); CFRelease(framesetter);&#125; 结果123456782017-02-23 15:19:42.578 CoreTextDemo[83004:902122] frame lines ( &quot;&lt;CTLine: 0x6080001ae8c0&gt;&#123;run count = 4, string range = (0, 24), width = 250.676, A/D/L = 12.72/4.08/0, glyph count = 24, runs = (\\n\\n&lt;CTRun: 0x7f8539f09720&gt;&#123;string range = (0, 5), string = \\&quot;\\\\u5BCC\\\\u6587\\\\u672C\\\\u5B66\\\\u4E60\\&quot;, attributes = &lt;CFBasicHash 0x608000267e40 [0x10d69fc70]&gt;&#123;type = mutable dict, count = 1,\\nentries =&gt;\\n\\t2 : &lt;CFString 0x10e05c788 [0x10d69fc70]&gt;&#123;contents = \\&quot;NSFont\\&quot;&#125; = &lt;CTFont: 0x7f8539f1f160&gt;&#123;name = PingFangSC-Regular, size = 12.000000, matrix = 0x0, descriptor = &lt;CTFontDescriptor: 0x608000086a90&gt;&#123;attributes = &lt;CFBasicHash 0x608000261640 [0x10d69fc70]&gt;&#123;type = mutable dict, count = 1,\\nentries =&gt;\\n\\t2 : &lt;CFString 0x10e062908 [0x10d69fc70]&gt;&#123;contents = \\&quot;NSFontNameAttribute\\&quot;&#125; = &lt;CFString 0x11af8e6c0 [0x10d69fc70]&gt;&#123;contents = \\&quot;PingFangSC-Regular\\&quot;&#125;\\n&#125;\\n&gt;&#125;&#125;\\n&#125;\\n&#125;\\n\\n\\n&lt;CTRun: 0x7f8539f0de20&gt;&#123;string range = (5, 1), string = \\&quot;/\\&quot;, attributes = &lt;CFBasicHash 0x6080002609c0 [0x10d69fc70]&gt;&#123;type = mutable dict, count = 1,\\nentries =&gt;\\n\\t2 : &lt;CFString 0x10e05c788 [0x10d69fc70]&gt;&#123;contents = \\&quot;NSFont\\&quot;&#125; = &lt;CTFont: 0x7f8539f04950&gt;&#123;name = Helvetica, size = 12.000000, matrix = 0x0, descriptor = &lt;CTFontDescriptor: 0x600000085960&gt;&#123;attributes = &lt;CFBasicHash 0x60000007dd40 [0x10d69fc70]&gt;&#123;type = mutable dict, count = 1,\\nentries =&gt;\\n\\t2 : &lt;CFString 0x10e062908 [0x10d69fc70]&gt;&#123;contents = \\&quot;NSFontNameAttribute\\&quot;&#125; = &lt;CFString 0x10e0548a8 [0x10d69fc70]&gt;&#123;contents = \\&quot;Helvetica\\&quot;&#125;\\n&#125;\\n&gt;&#125;&#125;\\n&#125;\\n&#125;\\n\\n\\n&lt;CTRun: 0x7f8539f2e9b0&gt;&#123;string range = (6, 14), string = \\&quot;\\\\u6162\\\\u6162\\\\u6765\\\\u5427\\\\u3002\\\\u4E0D\\\\u662F\\\\u4E00\\\\u671D\\\\u4E00\\\\u5915\\\\u4E4B\\\\u529F\\\\u3002\\&quot;, attributes = &lt;CFBasicHash 0x608000267e40 [0x10d69fc70]&gt;&#123;type = mutable dict, count = 1,\\nentries =&gt;\\n\\t2 : &lt;CFString 0x10e05c788 [0x10d69fc70]&gt;&#123;contents = \\&quot;NSFont\\&quot;&#125; = &lt;CTFont: 0x7f8539f1f160&gt;&#123;name = PingFangSC-Regular, size = 12.000000, matrix = 0x0, descriptor = &lt;CTFontDescriptor: 0x608000086a90&gt;&#123;attributes = &lt;CFBasicHash 0x608000261640 [0x10d69fc70]&gt;&#123;type = mutable dict, count = 1,\\nentries =&gt;\\n\\t2 : &lt;CFString 0x10e062908 [0x10d69fc70]&gt;&#123;contents = \\&quot;NSFontNameAttribute\\&quot;&#125; = &lt;CFString 0x11af8e6c0 [0x10d69fc70]&gt;&#123;contents = \\&quot;PingFangSC-Regular\\&quot;&#125;\\n&#125;\\n&gt;&#125;&#125;\\n&#125;\\n&#125;\\n\\n\\n&lt;CTRun: 0x7f8539f2eaf0&gt;&#123;string range = (20, 4), string = \\&quot;ok \\\\n\\&quot;, attributes = &lt;CFBasicHash 0x6080002609c0 [0x10d69fc70]&gt;&#123;type = mutable dict, count = 1,\\nentries =&gt;\\n\\t2 : &lt;CFString 0x10e05c788 [0x10d69fc70]&gt;&#123;contents = \\&quot;NSFont\\&quot;&#125; = &lt;CTFont: 0x7f8539f04950&gt;&#123;name = Helvetica, size = 12.000000, matrix = 0x0, descriptor = &lt;CTFontDescriptor: 0x600000085960&gt;&#123;attributes = &lt;CFBasicHash 0x60000007dd40 [0x10d69fc70]&gt;&#123;type = mutable dict, count = 1,\\nentries =&gt;\\n\\t2 : &lt;CFString 0x10e062908 [0x10d69fc70]&gt;&#123;contents = \\&quot;NSFontNameAttribute\\&quot;&#125; = &lt;CFString 0x10e0548a8 [0x10d69fc70]&gt;&#123;contents = \\&quot;Helvetica\\&quot;&#125;\\n&#125;\\n&gt;&#125;&#125;\\n&#125;\\n&#125;\\n\\n)\\n&#125;&quot;)2017-02-23 15:19:42.578 CoreTextDemo[83004:902122] frame origins 0.000000 14.0000002017-02-23 15:19:42.579 CoreTextDemo[83004:902122] frame att (null)2017-02-23 15:19:42.579 CoreTextDemo[83004:902122] frame path &lt;CGPath 0x60800003a300&gt;2017-02-23 15:19:42.579 CoreTextDemo[83004:902122] frame visibleString Range 0 242017-02-23 15:19:42.580 CoreTextDemo[83004:902122] frame String Range 0 30 从上面结果看 frame 没有设置 att 属性。那怎么设置属性值呢？请看 CTFramesetterRef 2 frame values下面是frame att 属性的key 通过 这些key 可以控制 frame 的绘制布局 kCTFrameProgressionAttributeName 文字绘制方向，有三个值， kCTFrameProgressionTopToBottom水平绘制 从上到下， kCTFrameProgressionRightToLeft 垂直绘制，从右到左， kCTFrameProgressionLeftToRight 垂直绘制，从左到右 kCTFramePathFillRuleAttributeName 在path路径的绘制规则。有两种 kCTFramePathFillEvenOdd 根据 CGContextEOFillPath 规则绘制 kCTFramePathFillWindingNumber 充满整个path 默认是kCTFramePathFillEvenOdd kCTFramePathWidthAttributeName 这个属性暂时不知道干嘛用的，使用起来无效 kCTFrameClippingPathsAttributeName 这个value 是array ，array 中必须包含 字典 ，字典的key值是kCTFramePathClippingPathAttributeName ，value是path，可选key kCTFramePathFillRuleAttributeName 可以配置path路径的填充方式 kCTFramePathClippingPathAttributeName 这个value是path kCTFrameProgressionAttributeName123NSMutableDictionary * Framedic = [NSMutableDictionary dictionary]; [Framedic setObject:@(kCTFrameProgressionLeftToRight) forKey:(__bridge NSString *)kCTFrameProgressionAttributeName]; CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), Path, (__bridge CFDictionaryRef) Framedic); 效果 kCTFrameProgressionRightToLeft123NSMutableDictionary * Framedic = [NSMutableDictionary dictionary]; [Framedic setObject:@(kCTFrameProgressionRightToLeft) forKey:(__bridge NSString *)kCTFrameProgressionAttributeName]; CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), Path, (__bridge CFDictionaryRef) Framedic); 效果 默认是kCTFrameProgressionTopToBottomkCTFramePathFillRuleAttributeName我认为这个主要是填充path 规则的 kCTFramePathFillEvenOdd 这种方式进行理解 什么是 CGContextEOFillPath 规则 //使用奇偶规则填充当前路径 修改路径代码如下：使一个大的矩形套一个小的矩形 123CGMutablePathRef Path = CGPathCreateMutable(); CGPathAddRect(Path, NULL ,CGRectMake(10 , 0 ,self.bounds.size.width-10 , self.bounds.size.height-60)); CGPathAddRect(Path, NULL ,CGRectMake(100 , 0 ,self.bounds.size.width-150 , self.bounds.size.height-60)); 结果显示 kCTFrameClippingPathsAttributeName 和 kCTFramePathClippingPathAttributeName1234567891011121314NSMutableArray * arr = [NSMutableArray array];NSMutableDictionary * fillDic = [NSMutableDictionary dictionary];CGMutablePathRef clippath = CGPathCreateMutable();CGPathAddRect(clippath, NULL ,CGRectMake(100 , 20 ,self.bounds.size.width-150 , self.bounds.size.height-60));[fillDic setObject:(__bridge id _Nonnull)(clippath) forKey:(__bridge NSString *)kCTFramePathClippingPathAttributeName];[arr addObject:fillDic];fillDic = [NSMutableDictionary dictionary]; clippath = CGPathCreateMutable();CGPathAddRect(clippath, NULL ,CGRectMake(10 , 20 ,10 , self.bounds.size.height-60));[fillDic setObject:(__bridge id _Nonnull)(clippath) forKey:(__bridge NSString *)kCTFramePathClippingPathAttributeName];[arr addObject:fillDic];[Framedic setObject:arr forKey:(__bridge NSString *)kCTFrameClippingPathsAttributeName]; 剪切上面的路径 。与 kCTFramePathFillRuleAttributeName 暂时看不出变化来，应该是这个里面的路径全部clip。可能与path 重叠有关系，目前没做具体研究。 3 frame typesCFTypeID CTFrameGetTypeID( void )返回一个CFTypeID 综合CFFrame.h api ，可以看出该类能获取到frame的信息是 CTLIne 和CTLine 的起点。见图 上图不包含剪切的路径。","tags":[]},{"title":"coreText概述","date":"2017-03-02T03:44:29.000Z","path":"2017/03/02/coreText概述/","text":"想学好一个framework ，以前总是看看简单的写写代码，实现基本功能。可是稍微遇到点困难的问题，就很难解决，所以这次我决定还是把所有的api都给实现一遍，看看功能，印象深刻。 coretext包含的类文件 CoreText.h CTDefines.h CTFont.h CTFontCollection.h CTFontDescriptor.h CTFontManager.h CTFontTraits.h CTFrame.h CTFramesetter.h CTGlyphInfo.h CTLine.h CTParagraphStyle.h CTRubyAnnotation.h CTRun.h CTRunDelegate.h CTStringAttributes.h CTTextTab.h CTTypesetter.h SFNTLayoutTypes.h SFNTTypes.h 以上是coretext.framework 包含的所有类 富文本字体规范字体的相关知识字体(Font):是一系列字号、样式和磅值相同的字符(例如:10磅黑体Palatino)。现多被视为字样的同义词 字面(Face):是所有字号的磅值和格式的综合 字体集(Font family):是一组相关字体(例如:Franklin family包括Franklin Gothic、Fran-klinHeavy和Franklin Compressed) 磅值(Weight):用于描述字体粗度。典型的磅值,从最粗到最细,有极细、细、book、中等、半粗、粗、较粗、极粗 样式(Style):字形有三种形式:Roman type是直体;oblique type是斜体;utakuc type是斜体兼曲线(比Roman type更像书法体)。 x高度(X height):指小写字母的平均高度(以x为基准)。磅值相同的两字母,x高度越大的字母看起来比x高度小的字母要大 Cap高度(Cap height):与x高度相似。指大写字母的平均高度(以C为基准) 下行字母(Descender):例如在字母q中,基线以下的字母部分叫下伸部分 上行字母(Ascender):x高度以上的部分(比如字母b)叫做上伸部分 基线(Baseline):通常在x、v、b、m下的那条线 描边(Stroke):组成字符的线或曲线。可以加粗或改变字符形状 衬线(Serif):用来使字符更可视的一条水平线。如字母左上角和下部的水平线。 无衬线(Sans Serif):可以让排字员不使用衬线装饰。 方形字(Block):这种字体的笔画使字符看起来比无衬线字更显眼,但还不到常见的衬线字的程度。例如Lubalin Graph就是方形字,这种字看起来好像是木头块刻的一样 手写体脚本(Calligraphic script):是一种仿效手写体的字体。例如Murray Hill或者Fraktur字体 艺术字(Decorative):像绘画般的字体 Pi符号(Pisymbol):非标准的字母数字字符的特殊符号。例如Wingdings和Mathematical Pi 连写(Ligature):是一系列连写字母如fi、fl、ffi或ffl。由于字些字母形状的原因经常被连写,故排字员已习惯将它们连写。 该框架的整体视窗组合图 坐标系UIKit框架的坐标系是左上角 而 coretext的坐标系是左下角 因此 要进行坐标系转换 简单demo我们学习这个框架从简单的demo慢慢扩充到复杂功能及所有api介绍 demo 代码$$ (void)drawRect:(CGRect)rect { CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetTextMatrix(context , CGAffineTransformIdentity); CGContextTranslateCTM(context , 0 ,self.bounds.size.height); CGContextScaleCTM(context, 1.0 ,-1.0); NSMutableAttributedString *mabstring = [[NSMutableAttributedString alloc]initWithString:@”富文本学习/慢慢来吧。不是一朝一夕之功。ok \\n ok ok”]; CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)mabstring); CGMutablePathRef Path = CGPathCreateMutable(); CGPathAddRect(Path, NULL ,CGRectMake(10 , 0 ,self.bounds.size.width-10 , self.bounds.size.height-20)); CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), Path, NULL); CTFrameDraw(frame,context); CGPathRelease(Path); CFRelease(framesetter);}$$显示效果 上面就是用coretext实现的简单效果，看着一点都不酷。一个UIlabel就能实现的效果。不过不要紧，慢慢往下看。","tags":[]},{"title":"coretext.framework 大全","date":"2017-02-23T03:07:41.000Z","path":"2017/02/23/coretext-framework-大全/","text":"CTFrameSetter.h创建 CTFrame 需要CTFrameSetter.h 类中 该类分四部分，Framesetter Types ， Framesetter Creation ，Frame Creation ， Frame Sizing 1.Framesetter TypesCFTypeID CTFramesetterGetTypeID( void ) 返回一个CTFramesetter 的 id 。 2.Framesetter Creation12CTFramesetterRef CTFramesetterCreateWithAttributedString(CFAttributedStringRef string )用CFAttributedStringRef 属性字符串创建一个CTFramesetterRef 获取Framesetter 只有这一种方式获取 3.Frame Creation12345678910111213141516CTFrameRef CTFramesetterCreateFrame( CTFramesetterRef framesetter, CFRange stringRange, CGPathRef path, CFDictionaryRef __nullable frameAttributes ) 该函数返回一个CTFrame 只有这一种方式创建CTFrameRef参数，需要一个CTFramesetterRef 需要一个CFRange 需要一个CGPathRef 需要一个CFDictionaryRef CFRange 控制的是文本的长度。如果设置长度是0，就是将attstr 字符串绘制到结束 CGPathRef 就是绘制区域 CFDictionaryRef 绘制CTFrame的相关属性设置，key值在CFFrame中 测试代码如下 12CFRange range = CFRangeMake(2, mabstring.length-4);CTFrameRef frame = CTFramesetterCreateFrame(framesetter,range, Path, (__bridge CFDictionaryRef) Framedic); 测试结果： 要是代码如下 12CFRange range = CFRangeMake(0, 0); CTFrameRef frame = CTFramesetterCreateFrame(framesetter,range, Path, (__bridge CFDictionaryRef) Framedic); 测试结果 从上下两个图看的出来，前面图的文本前后各少两个字。 所有字体还是对其排列。 1234CTTypesetterRef CTFramesetterGetTypesetter( CTFramesetterRef framesetter ) 根据CTFramesetterRef 获取一个CTTypesetterRef 目前还不知道CTTypesetterRef 有啥用 4.Frame Sizing1234567891011121314CGSize CTFramesetterSuggestFrameSizeWithConstraints( CTFramesetterRef framesetter, CFRange stringRange, CFDictionaryRef __nullable frameAttributes, CGSize constraints, CFRange * __nullable fitRange )获取Frame的大小这个函数适合创建Frame CGPath是矩形的算法，要是三角形等不规则图形就不适合 测试代码 12345678910111213141516171819202122232425262728293031 NSMutableDictionary * Framedic = [NSMutableDictionary dictionary]; [Framedic setObject:@(kCTFrameProgressionTopToBottom) forKey:(__bridge NSString *)kCTFrameProgressionAttributeName]; [Framedic setObject:@(kCTFramePathFillEvenOdd) forKey:(__bridge NSString *)kCTFramePathFillRuleAttributeName]; NSMutableArray * arr = [NSMutableArray array]; NSMutableDictionary * fillDic = [NSMutableDictionary dictionary]; CGMutablePathRef clippath = CGPathCreateMutable(); CGPathAddRect(clippath, NULL ,CGRectMake(100 , 20 ,self.bounds.size.width-150 , self.bounds.size.height-60)); [fillDic setObject:(__bridge id _Nonnull)(clippath) forKey:(__bridge NSString *)kCTFramePathClippingPathAttributeName]; [arr addObject:fillDic]; fillDic = [NSMutableDictionary dictionary]; clippath = CGPathCreateMutable(); CGPathAddRect(clippath, NULL ,CGRectMake(10 , 20 ,10 , self.bounds.size.height-60)); [fillDic setObject:(__bridge id _Nonnull)(clippath) forKey:(__bridge NSString *)kCTFramePathClippingPathAttributeName]; [arr addObject:fillDic];// [Framedic setObject:arr forKey:(__bridge NSString *)kCTFrameClippingPathsAttributeName]; CFRange range = CFRangeMake(0, 0); CTFrameRef frame = CTFramesetterCreateFrame(framesetter,range, Path, (__bridge CFDictionaryRef) Framedic); CGRect rectBoud = CGPathGetBoundingBox(Path); CFRange fitRange = CFRangeMake(0, 0); CGSize size =CTFramesetterSuggestFrameSizeWithConstraints(framesetter, range, (__bridge CFDictionaryRef) Framedic, rectBoud.size, &amp;fitRange); NSLog(@&quot; 获取frame 的大小 %f %f %ld %ld&quot;,size.height,size.width,fitRange.location,fitRange.location); 这个函数只能测试矩形排版，矩形内必须一次排满路径才行。不能有clip path存在才能准确。局限性比较大。 3.CTLine.hCTFrame布局是由Path 和CTLine 组成的。 我们能从CTLine中获取到什么信息呢。 我们从以下方面 Line Types, Line Creation,Line Access ,Line Measurement, Line Caret Positioning and Highlighting 1.Line Types12CFTypeID CTLineGetTypeID( void )获取CTLine的 CFTypeID 枚举值 CTLineBoundsOptions 和 CTLineTruncationType 12345678typedef CF_OPTIONS(CFOptionFlags, CTLineBoundsOptions) &#123; kCTLineBoundsExcludeTypographicLeading = 1 &lt;&lt; 0, kCTLineBoundsExcludeTypographicShifts = 1 &lt;&lt; 1, kCTLineBoundsUseHangingPunctuation = 1 &lt;&lt; 2, kCTLineBoundsUseGlyphPathBounds = 1 &lt;&lt; 3, kCTLineBoundsUseOpticalBounds = 1 &lt;&lt; 4, kCTLineBoundsIncludeLanguageExtents CT_ENUM_AVAILABLE(10_11, 8_0) = 1 &lt;&lt; 5,&#125;; 目前看上面的枚举值不知道具体有啥用。放过，等看完下面的回来补充。 12345678typedef CF_ENUM(uint32_t, CTLineTruncationType) &#123; kCTLineTruncationStart = 0, kCTLineTruncationEnd = 1, kCTLineTruncationMiddle = 2&#125;;这个kCTLineTruncationStart 截断头部kCTLineTruncationEnd 截断尾部kCTLineTruncationMiddle 截断中间 2.Line Creation123456789101112131415CTLineRef CTLineCreateWithAttributedString( CFAttributedStringRef attrString ) 根据CFAttributedStringRef 创建一个 CTLineRef 这个只能创建一行文本。//CTLine-(void)drawRect:(CGRect)rect&#123; CGContextRef context = UIGraphicsGetCurrentContext();// CGContextSetTextMatrix(context , CGAffineTransformIdentity); CGContextTranslateCTM(context , 0 ,self.bounds.size.height); CGContextScaleCTM(context, 1.0 ,-1.0); NSMutableAttributedString *mabstring = [[NSMutableAttributedString alloc]initWithString:@&quot;富文本学习富文本学习富文本学习富文本学习富文本学习富文本学习富文本学习富文本学习&quot;]; CTLineRef line = CTLineCreateWithAttributedString((__bridge CFAttributedStringRef)mabstring); CTLineDraw(line, context);&#125; 效果如下： 文字一行排开。 1234567891011121314151617181920212223242526272829CTLineRef __nullable CTLineCreateTruncatedLine( CTLineRef line, double width, CTLineTruncationType truncationType, CTLineRef __nullable truncationToken ) line 创建的截断的线 width 截断位置 truncationType 截断类型 头部截断还是中部尾部截断 truncationToken 这个是截断标志 不能让 truncationToken 线宽大于 width 要是大于width 函数返回NULL。 -(void)drawRect:(CGRect)rect&#123; CGContextRef context = UIGraphicsGetCurrentContext();// CGContextSetTextMatrix(context , CGAffineTransformIdentity); CGContextTranslateCTM(context , 0 ,self.bounds.size.height); CGContextScaleCTM(context, 1.0 ,-1.0); NSMutableAttributedString *mabstring = [[NSMutableAttributedString alloc]initWithString:@&quot;富文本学习慢慢来吧。不是一朝一夕之功。总是么盛大的饭卡多看看案发扩大到非卡卡打卡卡&quot;]; CTLineRef line = CTLineCreateWithAttributedString((__bridge CFAttributedStringRef)mabstring); mabstring = [[NSMutableAttributedString alloc]initWithString:@&quot;dd&quot;]; CTLineRef linetoken = CTLineCreateWithAttributedString((__bridge CFAttributedStringRef)mabstring); CTLineRef lineTru = CTLineCreateTruncatedLine(line, 300, kCTLineTruncationStart, linetoken);// CTLineDraw(line, context); CTLineDraw(lineTru, context);&#125; 头部截断效果如下： 12345678910111213141516171819202122232425CTLineRef __nullable CTLineCreateJustifiedLine( CTLineRef line, CGFloat justificationFactor, double justificationWidth ) line 参考线 justificationFactor 调整文字显示宽度比例 。大于等于1 就是justificationWidth 小于 1 大于零 宽度就是justificationFactor * justificationWidth justificationWidth 宽度。 调整宽度小于实际宽度，文字会被压扁。 //CTLine-(void)drawRect:(CGRect)rect&#123; CGContextRef context = UIGraphicsGetCurrentContext();// CGContextSetTextMatrix(context , CGAffineTransformIdentity); CGContextTranslateCTM(context , 0 ,self.bounds.size.height); CGContextScaleCTM(context, 1.0 ,-1.0); NSMutableAttributedString *mabstring = [[NSMutableAttributedString alloc]initWithString:@&quot;富文本学习&quot;]; CTLineRef line = CTLineCreateWithAttributedString((__bridge CFAttributedStringRef)mabstring); CTLineRef lineJustified = CTLineCreateJustifiedLine(line, 1, 300); CTLineDraw(line, context); CTLineDraw(lineJustified, context);&#125; 效果如图 要是文本过长，justificationFactor 必须大于等于 1 否则，不进行CTLine绘制。 代码如下 123456789101112131415//CTLine-(void)drawRect:(CGRect)rect&#123; CGContextRef context = UIGraphicsGetCurrentContext();// CGContextSetTextMatrix(context , CGAffineTransformIdentity); CGContextTranslateCTM(context , 0 ,self.bounds.size.height); CGContextScaleCTM(context, 1.0 ,-1.0); NSMutableAttributedString *mabstring = [[NSMutableAttributedString alloc]initWithString:@&quot;富文本学习慢慢来吧。不是一朝一夕之功。总是么盛大的饭卡多看看案发扩大到非卡卡打卡卡&quot;]; CTLineRef line = CTLineCreateWithAttributedString((__bridge CFAttributedStringRef)mabstring); CTLineRef lineJustified = CTLineCreateJustifiedLine(line, 1, 300); // CTLineDraw(line, context); CTLineDraw(lineJustified, context);&#125; 效果图： 文字压扁了。 3.Line Access CFIndex CTLineGetGlyphCount( CTLineRef line ) 获取Glyph的个数 CFArrayRef CTLineGetGlyphRuns(CTLineRef line ) 获取CTRunRef数组 CFRange CTLineGetStringRange(CTLineRef line ) 获取线所在字符串的范围 double CTLineGetPenOffsetForFlush( CTLineRef line, CGFloat flushFactor, double flushWidth ) 文本flushFactor比例的距离到flushWidthflushFactor的距离 flushFactor大于1 相当于1操作。公式 假设文本长度textWidth 结果result=flushWidth flushFactor - flushFactor * textWidth void CTLineDraw( CTLineRef line, CGContextRef context ) 绘制线。位置是从底部向上绘制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445-(void)drawRect:(CGRect)rect&#123; CGContextRef context = UIGraphicsGetCurrentContext();// CGContextSetTextMatrix(context , CGAffineTransformIdentity); CGContextTranslateCTM(context , 0 ,self.bounds.size.height); CGContextScaleCTM(context, 1.0 ,-1.0); NSMutableAttributedString *mabstring = [[NSMutableAttributedString alloc]initWithString:@&quot;富文本学习慢慢来吧。不是一朝一夕之功。总是么盛大的饭卡多看看案发扩大到非卡卡打卡卡&quot;]; CTLineRef line = CTLineCreateWithAttributedString((__bridge CFAttributedStringRef)mabstring); mabstring = [[NSMutableAttributedString alloc]initWithString:@&quot;dd&quot;]; CTLineRef linetoken = CTLineCreateWithAttributedString((__bridge CFAttributedStringRef)mabstring); CTLineRef lineTru = CTLineCreateTruncatedLine(line, 300, kCTLineTruncationStart, linetoken);// CTLineDraw(line, context); CTLineDraw(line, context); double offset = CTLineGetPenOffsetForFlush(line, 2, 100); NSLog(@&quot;line offset %f&quot;,offset); ///access CFIndex index = CTLineGetGlyphCount(lineTru); NSLog(@&quot;line glyph %ld&quot;,index); index = CTLineGetGlyphCount(line); NSLog(@&quot;line glyph %ld&quot;,index); NSArray * runArr = (__bridge NSArray *) CTLineGetGlyphRuns(line); NSLog(@&quot;runArr %@&quot; ,runArr); CFRange range = CTLineGetStringRange(lineTru ); NSLog(@&quot;line range %ld %ld&quot;,range.location,range.length); range = CTLineGetStringRange(line); NSLog(@&quot;line range %ld %ld&quot;,range.location,range.length);&#125;结果：2017-02-24 17:07:16.149 CoreTextDemo[5171:125678] line offset 0.0000002017-02-24 17:07:16.149 CoreTextDemo[5171:125678] line glyph 252017-02-24 17:07:16.149 CoreTextDemo[5171:125678] line glyph 412017-02-24 17:07:16.150 CoreTextDemo[5171:125678] runArr ( &quot;&lt;CTRun: 0x7febf3709730&gt;&#123;string range = (0, 41), string = \\&quot;\\\\u5BCC\\\\u6587\\\\u672C\\\\u5B66\\\\u4E60\\\\u6162\\\\u6162\\\\u6765\\\\u5427\\\\u3002\\\\u4E0D\\\\u662F\\\\u4E00\\\\u671D\\\\u4E00\\\\u5915\\\\u4E4B\\\\u529F\\\\u3002\\\\u603B\\\\u662F\\\\u4E48\\\\u76DB\\\\u5927\\\\u7684\\\\u996D\\\\u5361\\\\u591A\\\\u770B\\\\u770B\\\\u6848\\\\u53D1\\\\u6269\\\\u5927\\\\u5230\\\\u975E\\\\u5361\\\\u5361\\\\u6253\\\\u5361\\\\u5361\\&quot;, attributes = &lt;CFBasicHash 0x600000266940 [0x10f4b1c70]&gt;&#123;type = mutable dict, count = 1,\\nentries =&gt;\\n\\t2 : &lt;CFString 0x10fe6e788 [0x10f4b1c70]&gt;&#123;contents = \\&quot;NSFont\\&quot;&#125; = &lt;CTFont: 0x7febf3709600&gt;&#123;name = PingFangSC-Regular, size = 12.000000, matrix = 0x0, descriptor = &lt;CTFontDescriptor: 0x608000094e60&gt;&#123;attributes = &lt;CFBasicHash 0x60800026d980 [0x10f4b1c70]&gt;&#123;type = mutable dict, count = 1,\\nentries =&gt;\\n\\t2 : &lt;CFString 0x10fe74908 [0x10f4b1c70]&gt;&#123;contents = \\&quot;NSFontNameAttribute\\&quot;&#125; = &lt;CFString 0x11cda06c0 [0x10f4b1c70]&gt;&#123;contents = \\&quot;PingFangSC-Regular\\&quot;&#125;\\n&#125;\\n&gt;&#125;&#125;\\n&#125;\\n&#125;&quot;)2017-02-24 17:07:16.150 CoreTextDemo[5171:125678] line range 0 412017-02-24 17:07:16.152 CoreTextDemo[5171:125678] line range 0 41 从上面结果看：CTLineGetStringRange获取的范围可能会有问题。用的时候要小心（要是自己创建CTline的话）这个只是自己创建的CTline不准，而CTFrame创建的CTLine是没问题的。 CTLineGetPenOffsetForFlush 函数相当于 文本到某点还有多少距离。 测试代码是 ` NSMutableAttributedString *mabstring = [[NSMutableAttributedString alloc]initWithString:@”富文本学”]; CTLineRef line = CTLineCreateWithAttributedString((__bridge CFAttributedStringRef)mabstring); CTLineDraw(line, context); double offset = CTLineGetPenOffsetForFlush(line,0.5, 300); NSLog(@&quot;line offset %f&quot;,offset);` 如图 打印结果是2017-02-24 19:33:15.061 CoreTextDemo[4317:74402] line offset 126.000000 4.Line Measurement CTLineGetTypographicBounds( CTLineRef line,CGFloat __nullable ascent,CGFloat nullable descent, CGFloat * nullable leading ) 获取线 的ascent descent leading ,返回宽度 CGRect CTLineGetBoundsWithOptions(CTLineRef line,CTLineBoundsOptions options ) 目前还不知道CTLineBoundsOptions 代表啥。 应该与富文本的设置有关。暂时不做研究 double CTLineGetTrailingWhitespaceWidth(CTLineRef line ) 目前还不会用 CGRect CTLineGetImageBounds(CTLineRef line,CGContextRef __nullable context ) 目前还不会用 12345CGFloat ascent;CGFloat descent;CGFloat leading;CTLineGetTypographicBounds(line, &amp;ascent, &amp;descent, &amp;leading);NSLog(@&quot;line ascent %f,descent %f,leading %f&quot;,ascent,descent,leading); 5.Line Caret Positioning and Highlighting CFIndex CTLineGetStringIndexForPosition(CTLineRef line,CGPoint position ) 获取线position位置的String index CGFloat CTLineGetOffsetForStringIndex(CTLineRef line,CFIndex charIndex,CGFloat * __nullable secondaryOffset ) 获取index位置字符的偏移量。目前不知道 返回结果和secondaryOffset 的区别 void CTLineEnumerateCaretOffsets(CTLineRef line,void (^block)(double offset, CFIndex charIndex, bool leadingEdge, bool* stop) ) CT_AVAILABLE(10_11, 9_0) 返回每个字体的前后边沿 12345678910111213141516171819202122CFIndex stringIndex = CTLineGetStringIndexForPosition(line, CGPointMake(20,3 )); NSLog(@&quot;line StringIndex %ld&quot;,stringIndex); CGFloat secondaryOffset; CGFloat offsetIndex = CTLineGetOffsetForStringIndex(line, 2,&amp;secondaryOffset ); NSLog(@&quot;line IndexOffset %lf ,secondaryOffset %lf&quot;,offsetIndex,secondaryOffset); CTLineEnumerateCaretOffsets(line, ^(double offset, CFIndex charIndex, bool leadingEdge, bool * _Nonnull stop) &#123; NSLog(@&quot; offset %lf,charindex %ld,leadingEdge %d&quot;,offset,charIndex,leadingEdge); &#125;);结果2017-02-27 11:29:21.537 CoreTextDemo[6188:222405] line StringIndex 22017-02-27 11:29:21.537 CoreTextDemo[6188:222405] line IndexOffset 24.000000 ,secondaryOffset 24.0000002017-02-27 11:29:21.537 CoreTextDemo[6188:222405] offset 0.000000,charindex 0,leadingEdge 12017-02-27 11:29:21.538 CoreTextDemo[6188:222405] offset 12.000000,charindex 0,leadingEdge 02017-02-27 11:29:21.538 CoreTextDemo[6188:222405] offset 12.000000,charindex 1,leadingEdge 12017-02-27 11:29:21.538 CoreTextDemo[6188:222405] offset 24.000000,charindex 1,leadingEdge 02017-02-27 11:29:21.538 CoreTextDemo[6188:222405] offset 24.000000,charindex 2,leadingEdge 12017-02-27 11:29:21.538 CoreTextDemo[6188:222405] offset 36.000000,charindex 2,leadingEdge 02017-02-27 11:29:21.538 CoreTextDemo[6188:222405] offset 36.000000,charindex 3,leadingEdge 12017-02-27 11:29:21.539 CoreTextDemo[6188:222405] offset 48.000000,charindex 3,leadingEdge 0 CTLine 的模型图 CTRun.hCTLine是由CTRun组成的。 我们通过以下几个方面来看看CTRun 1.Glyph Run Types 2Glyph Run Access 1.Glyph Run TypesCFTypeID CTRunGetTypeID( void ) 获取CTRunRef 的 CFTypeID 12345678910111213typedef CF_OPTIONS(uint32_t, CTRunStatus)&#123; kCTRunStatusNoStatus = 0, kCTRunStatusRightToLeft = (1 &lt;&lt; 0), kCTRunStatusNonMonotonic = (1 &lt;&lt; 1), kCTRunStatusHasNonIdentityMatrix = (1 &lt;&lt; 2)&#125;;Run的状态kCTRunStatusNoStatus 没有属性kCTRunStatusRightToLeft 暂时不知道干嘛的 kCTRunStatusNonMonotonic 暂时不知道干嘛的kCTRunStatusHasNonIdentityMatrix 暂时不知道干嘛的 2.Glyph Run Access CTRunGetGlyphCount (CTRunRef run ) 获取run的字体个数 CFDictionaryRef CTRunGetAttributes(CTRunRef run ) 获取run的属性 CTRunStatus CTRunGetStatus(CTRunRef run ) 获取 status 不知道这个干嘛用 const CGGlyph * __nullable CTRunGetGlyphsPtr(CTRunRef run ) 获取一个CGGlyph 指针数组 void CTRunGetGlyphs(CTRunRef run,CFRange range,CGGlyph buffer[] ) 获取数据CGGlyph 在范围range const CGPoint * __nullable CTRunGetPositionsPtr(CTRunRef run ) 获取每个glyph 字体的起始位置数组 void CTRunGetPositions(CTRunRef run,CFRange range,CGPoint buffer[] ) 获取数据获取数据CGGlyph位置 在范围range const CGSize * __nullable CTRunGetAdvancesPtr(CTRunRef run ) 获取CGGlyph 的大小数组 void CTRunGetAdvances(CTRunRef run,CFRange range,CGSize buffer[] ) 获取数据获取数据CGGlyph大小 在范围range const CFIndex * __nullable CTRunGetStringIndicesPtr(CTRunRef run ) 获取CGGlyph 在整个字符串index数组的大小数组 void CTRunGetStringIndices(CTRunRef run,CFRange range,CFIndex buffer[] ) 获取数据获取数据CGGlyph在整个字符串index处数组 在范围range CFRange CTRunGetStringRange(CTRunRef run ) 获取run在字符串中的range double CTRunGetTypographicBounds(CTRunRef run,CFRange range,CGFloat __ nullable ascent,CGFloat nullable descent,CGFloat * nullable leading ) 获取run 在范围range的的相关信息 返回宽度 CGRect CTRunGetImageBounds( CTRunRef run,CGContextRef __nullable context,CFRange range ) 获取一个rect 具体是怎么样子不知道 CGAffineTransform CTRunGetTextMatrix(CTRunRef run ) 获取run 的二维矩阵 void CTRunDraw(CTRunRef run,CGContextRef context,CFRange range ) 绘制run 位置什么的不变。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128 CGContextRef context = UIGraphicsGetCurrentContext();// CGContextSetTextMatrix(context , CGAffineTransformIdentity); CGContextTranslateCTM(context , 0 ,self.bounds.size.height); CGContextScaleCTM(context, 1.0 ,-1.0); NSMutableAttributedString *mabstring = [[NSMutableAttributedString alloc]initWithString:@&quot;富文本学吧&quot;]; NSDictionary * dic = [NSDictionary dictionaryWithObject:[UIFont systemFontOfSize:18] forKey:(__bridge NSString *)kCTFontAttributeName]; ///设置字体 [mabstring setAttributes:dic range:NSMakeRange(2, 3)]; CTLineRef line = CTLineCreateWithAttributedString((__bridge CFAttributedStringRef)mabstring); mabstring = [[NSMutableAttributedString alloc]initWithString:@&quot;dd&quot;]; CTLineRef linetoken = CTLineCreateWithAttributedString((__bridge CFAttributedStringRef)mabstring); CTLineRef lineTru = CTLineCreateTruncatedLine(line, 300, kCTLineTruncationStart, linetoken);// CTLineDraw(line, context); // CTLineDraw(line, context); double offset = CTLineGetPenOffsetForFlush(line,0.5, 300); NSLog(@&quot;line offset %f&quot;,offset); UIView * view =[[UIView alloc]initWithFrame:CGRectMake(300/2-offset, self.bounds.size.height-64, offset, 10)]; [self addSubview:view]; view.backgroundColor =[UIColor redColor]; view =[[UIView alloc]initWithFrame:CGRectMake(0, self.bounds.size.height-64, 300/2, 10)]; [self addSubview:view]; view.alpha = 0.4; view.backgroundColor =[UIColor greenColor]; ///access CFIndex index = CTLineGetGlyphCount(lineTru); NSLog(@&quot;line glyph %ld&quot;,index); index = CTLineGetGlyphCount(line); NSLog(@&quot;line glyph %ld&quot;,index); NSArray * runArr = (__bridge NSArray *) CTLineGetGlyphRuns(line); NSLog(@&quot;runArr %@&quot; ,runArr); if (runArr.count&gt;1) &#123; CTRunRef run = (__bridge CTRunRef)runArr[1]; CFIndex index = CTRunGetGlyphCount(run); NSLog(@&quot;Run glyph 个数 %ld&quot;,index); NSDictionary * dic = (__bridge NSDictionary * ) CTRunGetAttributes(run); NSLog(@&quot;run att %@&quot;,dic); CTRunStatus status = CTRunGetStatus(run); NSLog(@&quot;run status %d&quot;,status); const CGGlyph * glyph = CTRunGetGlyphsPtr(run); const CGPoint * point = CTRunGetPositionsPtr(run); const CGSize * size = CTRunGetAdvancesPtr(run); const CFIndex * indexs = CTRunGetStringIndicesPtr(run); for (int i=0; i&lt;index; i++) &#123; NSLog(@&quot;run glyph %d&quot;,glyph[i]); NSLog(@&quot;run point %lf %lf&quot;,point[i].x,point[i].y); NSLog(@&quot;run size %lf %lf&quot;,size[i].width,size[i].height); NSLog(@&quot;run index %ld&quot;,indexs[i]); &#125; CGGlyph buffer[2]; CGPoint pointPos[2]; CGSize sizeBuffer[2]; CFIndex indexBuffer[2]; CTRunGetGlyphs(run, CFRangeMake(0, 2), buffer); NSLog(@&quot;run glyph %d %d&quot;,buffer[0],buffer[1]); CTRunGetPositions(run, CFRangeMake(0, 2), pointPos); NSLog(@&quot;run glyph point %lf %lf&quot;,pointPos[0].x,pointPos[1].y); CTRunGetAdvances(run, CFRangeMake(0, 2), sizeBuffer); NSLog(@&quot;run glyph size %lf %lf&quot;,sizeBuffer[0].width,sizeBuffer[1].height); CTRunGetStringIndices(run,CFRangeMake(0, 2),indexBuffer); NSLog(@&quot;run glyph index %ld %ld&quot;,indexBuffer[0],indexBuffer[1]); CFRange stringRange = CTRunGetStringRange(run); NSLog(@&quot;run string range %ld %ld&quot;,stringRange.location,stringRange.length); CGFloat ascent; CGFloat descent; CGFloat leading; CTRunGetTypographicBounds(run, CFRangeMake(1, 2), &amp;ascent, &amp;descent, &amp;leading); NSLog(@&quot;run ascent %f,descent %f,leading %f&quot;,ascent,descent,leading); CGRect imageRect= CTRunGetImageBounds(run, context, CFRangeMake(1, 2)); NSLog(@&quot;不知道能干嘛 run image rect %@&quot;,NSStringFromCGRect(imageRect)); UIView * view = [[UIView alloc]initWithFrame:imageRect]; view.backgroundColor =[UIColor redColor ]; view.alpha = 0.8; [self addSubview:view]; CGAffineTransform transfrom = CTRunGetTextMatrix(run); NSLog(@&quot;run transform %@&quot;,NSStringFromCGAffineTransform(transfrom)); CTRunDraw(run, context, CFRangeMake(1, 2)); &#125; 结果 2017-02-27 15:12:46.162 CoreTextDemo[11205:345484] line offset 110.4870002017-02-27 15:12:46.163 CoreTextDemo[11205:345484] line glyph 52017-02-27 15:12:46.163 CoreTextDemo[11205:345484] line glyph 52017-02-27 15:12:46.163 CoreTextDemo[11205:345484] runArr ( &quot;&lt;CTRun: 0x7fdb89c28330&gt;&#123;string range = (0, 2), string = \\&quot;\\\\u5BCC\\\\u6587\\&quot;, attributes = &lt;CFBasicHash 0x60800026abc0 [0x10117ec70]&gt;&#123;type = mutable dict, count = 1,\\nentries =&gt;\\n\\t2 : &lt;CFString 0x101b3b788 [0x10117ec70]&gt;&#123;contents = \\&quot;NSFont\\&quot;&#125; = &lt;CTFont: 0x7fdb89c28130&gt;&#123;name = PingFangSC-Regular, size = 12.000000, matrix = 0x0, descriptor = &lt;CTFontDescriptor: 0x60000008a640&gt;&#123;attributes = &lt;CFBasicHash 0x600000271a80 [0x10117ec70]&gt;&#123;type = mutable dict, count = 1,\\nentries =&gt;\\n\\t2 : &lt;CFString 0x101b41908 [0x10117ec70]&gt;&#123;contents = \\&quot;NSFontNameAttribute\\&quot;&#125; = &lt;CFString 0x10ea6d6c0 [0x10117ec70]&gt;&#123;contents = \\&quot;PingFangSC-Regular\\&quot;&#125;\\n&#125;\\n&gt;&#125;&#125;\\n&#125;\\n&#125;&quot;, &quot;&lt;CTRun: 0x7fdb89c3d710&gt;&#123;string range = (2, 3), string = \\&quot;\\\\u672C\\\\u5B66\\\\u5427\\&quot;, attributes = &lt;CFBasicHash 0x60800026a8c0 [0x10117ec70]&gt;&#123;type = mutable dict, count = 1,\\nentries =&gt;\\n\\t2 : &lt;CFString 0x101b3b788 [0x10117ec70]&gt;&#123;contents = \\&quot;NSFont\\&quot;&#125; = &lt;CTFont: 0x7fdb89c3d3f0&gt;&#123;name = .PingFangSC-Regular, size = 18.000000, matrix = 0x0, descriptor = &lt;CTFontDescriptor: 0x60000008d570&gt;&#123;attributes = &lt;CFBasicHash 0x600000279140 [0x10117ec70]&gt;&#123;type = mutable dict, count = 1,\\nentries =&gt;\\n\\t2 : &lt;CFString 0x101b41908 [0x10117ec70]&gt;&#123;contents = \\&quot;NSFontNameAttribute\\&quot;&#125; = &lt;CFString 0x101b39be8 [0x10117ec70]&gt;&#123;contents = \\&quot;.PingFangSC-Regular\\&quot;&#125;\\n&#125;\\n&gt;&#125;&#125;\\n&#125;\\n&#125;&quot;)2017-02-27 15:12:46.171 CoreTextDemo[11205:345484] Run glyph 个数 32017-02-27 15:12:46.171 CoreTextDemo[11205:345484] run att &#123; NSFont = &quot;&lt;UICTFont: 0x7fdb89c3d3f0&gt; font-family: \\&quot;.PingFangSC-Regular\\&quot;; font-weight: normal; font-style: normal; font-size: 18.00pt&quot;;&#125;2017-02-27 15:12:46.172 CoreTextDemo[11205:345484] run status 02017-02-27 15:12:46.172 CoreTextDemo[11205:345484] run glyph 36762017-02-27 15:12:46.172 CoreTextDemo[11205:345484] run point 24.000000 0.0000002017-02-27 15:12:46.172 CoreTextDemo[11205:345484] run size 18.342000 0.0000002017-02-27 15:12:46.172 CoreTextDemo[11205:345484] run index 22017-02-27 15:12:46.172 CoreTextDemo[11205:345484] run glyph 25732017-02-27 15:12:46.173 CoreTextDemo[11205:345484] run point 42.342000 0.0000002017-02-27 15:12:46.173 CoreTextDemo[11205:345484] run size 18.342000 0.0000002017-02-27 15:12:46.173 CoreTextDemo[11205:345484] run index 32017-02-27 15:12:46.173 CoreTextDemo[11205:345484] run glyph 19292017-02-27 15:12:46.173 CoreTextDemo[11205:345484] run point 60.684000 0.0000002017-02-27 15:12:46.173 CoreTextDemo[11205:345484] run size 18.342000 0.0000002017-02-27 15:12:46.255 CoreTextDemo[11205:345484] run index 42017-02-27 15:12:46.255 CoreTextDemo[11205:345484] run glyph 3676 25732017-02-27 15:12:46.256 CoreTextDemo[11205:345484] run glyph point 24.000000 0.0000002017-02-27 15:12:46.256 CoreTextDemo[11205:345484] run glyph size 18.342000 0.0000002017-02-27 15:12:46.256 CoreTextDemo[11205:345484] run glyph index 2 32017-02-27 15:12:46.256 CoreTextDemo[11205:345484] run string range 2 32017-02-27 15:12:46.256 CoreTextDemo[11205:345484] run ascent 15.480000,descent 2.520000,leading 0.5400002017-02-27 15:12:46.257 CoreTextDemo[11205:345484] 不知道能干嘛 run image rect &#123;&#123;19.619999999999997, -1.7459999999999998&#125;, &#123;34.128, 16.631999999999998&#125;&#125;2017-02-27 15:12:46.257 CoreTextDemo[11205:345484] run transform [1, 0, 0, 1, 0, 0] 从run 的api中可以看出，run 是CGGlyph 组成的。CGGlayph可以用来创建字体。 CTRun CTLine CTFrame CTFrameSetter 这些就可以完成文本的布局了。 CTStringAttributes.h完成丰富的布局离不开文本String 下面学习 学习CTStringAttributes 配置富文本的key key value 注意事项 kCTFontAttributeName CTFontRef 配置富文本的字体默认是 Helvetica 12 kCTForegroundColorFromContextAttributeName CFBooleanRef Default is false ，具体想法不清楚 kCTKernAttributeName CFNumberRef 字符之间的间隔 默认是 0.0 kCTLigatureAttributeName CFNumberRef 默认值是1 ，用法不清楚 kCTForegroundColorAttributeName CGColorRef 默认是black 。设置字体颜色 kCTBackgroundColorAttributeName CGColorRef 默认透明，背景颜色 kCTParagraphStyleAttributeName CTParagraphStyleRef 默认不设置该属性。可以设置例如line 对对齐，写的方向，tab规则等。 kCTStrokeWidthAttributeName CFNumberRef 线宽。默认0.0 kCTStrokeColorAttributeName CGColorRef 线的颜色。默认是 foreground颜色。没啥变化，有时间再研究 kCTUnderlineStyleAttributeName CFNumberRef 下划线 类型有 CTUnderlineStyle kCTSuperscriptAttributeName CFNumberRef 默认是0.上标还是下标。 要 the specified font。具体是啥字体不知道。 -1 下标 1 上标。暂时设置没效果。 kCTUnderlineColorAttributeName CGColorRef 默认是foreground 颜色 ，下划线颜色.设置不起总用 kCTVerticalFormsAttributeName CFBooleanRef value false horizontal value true vertical kCTHorizontalInVerticalFormsAttributeName CFNumberRef 默认是0. value 是1 to 4 只有设置 kCTVerticalFormsAttributeName才起作用.目前不知道杂用。没效果 kCTGlyphInfoAttributeName CTGlyphInfoRef 改value 不知道杂用，暂时过 kCTCharacterShapeAttributeName CFNumberRef 9.0 以后才能用 ，暂时value 值不知道咋用 kCTLanguageAttributeName CFStringRef 具体value值有哪些。暂时不管。 kCTRunDelegateAttributeName CTRunDelegateRef 可以用来图文混拍的东西。替代的每一个cgglyph kCTBaselineClassAttributeName CFStringRef value 有 kCTBaselineClassRoman， kCTBaselineClassIdeographicCentered， kCTBaselineClassIdeographicLow， kCTBaselineClassIdeographicHigh， kCTBaselineClassHanging， kCTBaselineClassMath，暂时不知道杂用 kCTBaselineInfoAttributeName CFDictionaryRef key 是 value 有 kCTBaselineClassRoman， kCTBaselineClassIdeographicCentered， kCTBaselineClassIdeographicLow， kCTBaselineClassIdeographicHigh， kCTBaselineClassHanging， kCTBaselineClassMath，暂时不知道杂用，不会用 kCTBaselineReferenceInfoAttributeName CFDictionaryRef key 是 value 有 kCTBaselineClassRoman， kCTBaselineClassIdeographicCentered， kCTBaselineClassIdeographicLow， kCTBaselineClassIdeographicHigh， kCTBaselineClassHanging， kCTBaselineClassMath，暂时不知道杂用，不会用 kCTWritingDirectionAttributeName CFArray 数组中是 number 。暂时不会用 kCTRubyAnnotationAttributeName CTRubyAnnotation 暂时不会用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134-(void)setstring:(NSMutableAttributedString * )beginStr appendString:(CFStringRef )key value:(id)value string:(NSString *)string&#123; NSRange range = [beginStr.string rangeOfString:string]; NSMutableDictionary * dic = [NSMutableDictionary dictionaryWithObject:value forKey:(__bridge NSString *)key]; [beginStr setAttributes:dic range:range];&#125;-(void)string:(NSMutableAttributedString * )beginStr appendString:(CFStringRef )key value:(id)value string:(NSString *)string&#123; NSMutableAttributedString *nextMabstring = [[NSMutableAttributedString alloc]initWithString:string]; NSMutableDictionary * dic = [NSMutableDictionary dictionaryWithObject:value forKey:(__bridge NSString *)key]; [nextMabstring setAttributes:dic range:NSMakeRange(0, nextMabstring.length)]; [beginStr appendAttributedString:nextMabstring]; &#125;-(void)drawRect:(CGRect)rect&#123; NSMutableAttributedString *mabstring = [[NSMutableAttributedString alloc]initWithString:@&quot;&quot;]; [self string:mabstring appendString:kCTFontAttributeName value:[UIFont systemFontOfSize:24] string:@&quot;kCTFontAttributeName&quot;]; [self string:mabstring appendString:kCTForegroundColorFromContextAttributeName value:@(YES) string:@&quot;kCTForegroundColorFromContextAttributeName&quot;]; [self string:mabstring appendString:kCTKernAttributeName value:@(30) string:@&quot;kCTKernAttributeName&quot;]; [self string:mabstring appendString:kCTLigatureAttributeName value:@(2) string:@&quot;kCTLigatureAttributeName&quot;]; [self string:mabstring appendString:kCTForegroundColorAttributeName value:(id)([UIColor redColor].CGColor) string:@&quot;kCTForegroundColorAttributeName&quot;]; [self string:mabstring appendString:kCTBackgroundColorAttributeName value:(id)([UIColor blueColor].CGColor) string:@&quot;kCTBackgroundColorAttributeName&quot;]; CTParagraphStyleSetting setting[1] ; CGFloat vale =30; setting[0].spec = kCTParagraphStyleSpecifierLineSpacingAdjustment; setting[0].valueSize =sizeof(CGFloat); setting[0].value = &amp;vale; CTParagraphStyleRef stlye = CTParagraphStyleCreate(setting, 1); [self string:mabstring appendString:kCTParagraphStyleAttributeName value:(id)(stlye) string:@&quot;kCTParagraphStyleAttributeName&quot;]; [self string:mabstring appendString:kCTStrokeWidthAttributeName value:(id)(@(5)) string:@&quot;kCTStrokeWidthAttributeName&quot;]; [self string:mabstring appendString:kCTStrokeColorAttributeName value:(id)([UIColor redColor].CGColor) string:@&quot;kCTStrokeColorAttributeName&quot;]; [self string:mabstring appendString:kCTUnderlineStyleAttributeName value:(id)(@(kCTUnderlineStyleDouble)) string:@&quot;kCTUnderlineStyleAttributeName&quot;]; [self string:mabstring appendString:kCTUnderlineStyleAttributeName value:(id)(@(kCTUnderlineStyleThick)) string:@&quot;kCTUnderlineStyleAttributeName&quot;]; [self string:mabstring appendString:kCTUnderlineStyleAttributeName value:(id)(@(kCTUnderlineStyleSingle)) string:@&quot;kCTUnderlineStyleAttributeName&quot;]; [self string:mabstring appendString:kCTSuperscriptAttributeName value:(id)(@(-1)) string:@&quot;kCTSuperscriptAttributeName&quot;]; [self string:mabstring appendString:kCTUnderlineStyleAttributeName value:(id)(@(kCTUnderlineStyleSingle)) string:@&quot;kCTUnderlineColorAttributeName&quot;]; [self setstring:mabstring appendString:kCTUnderlineColorAttributeName value:(id)([UIColor redColor].CGColor) string:@&quot;kCTUnderlineColorAttributeName&quot;]; [self string:mabstring appendString:kCTVerticalFormsAttributeName value:(id)(@(YES)) string:@&quot;kCTVerticalFormsAttributeName&quot;]; [self string:mabstring appendString:kCTVerticalFormsAttributeName value:(id)(@(YES)) string:@&quot;kCTHorizontalInVerticalFormsAttributeName&quot;];// [self setstring:mabstring appendString:kCTHorizontalInVerticalFormsAttributeName value:(id)(@(3)) string:@&quot;kCTHorizontalInVerticalFormsAttributeName&quot;]; // [self string:mabstring appendString:kCTGlyphInfoAttributeName value:(id)([UIColor blueColor].CGColor) string:@&quot;kCTGlyphInfoAttributeName&quot;]; // [self string:mabstring appendString:kCTCharacterShapeAttributeName value:(id)(@(3)) string:@&quot;kCTCharacterShapeAttributeName&quot;]; [self string:mabstring appendString:kCTLanguageAttributeName value:(id)(@&quot;Helvetica&quot;) string:@&quot;kCTLanguageAttributeName&quot;]; CTRunDelegateDeallocateCallback deallocateCallback= CTRunDelegateDeallocateCallbackFunction; NSLog(@&quot;CTRunDelegateGetAscentCallback 获取ascent&quot;); CTRunDelegateGetAscentCallback ascentCallback= CTRunDelegateGetAscentCallbackFunction; CTRunDelegateGetDescentCallback descentCallback = CTRunDelegateGetDescentCallbackFunction; CTRunDelegateGetWidthCallback widthCallBack = CTRunDelegateGetWidthCallbackFunction; CTRunDelegateCallbacks callBack ; callBack.version =kCTRunDelegateCurrentVersion; callBack.dealloc = deallocateCallback; callBack.getAscent = ascentCallback; callBack.getDescent = descentCallback; callBack.getWidth = widthCallBack; CTRunDelegateRef delegate= CTRunDelegateCreate(&amp;callBack, NULL); ///获取delegate值 [self string:mabstring appendString:kCTRunDelegateAttributeName value:(__bridge id)(delegate) string:@&quot;kCTRunDelegateAttributeName&quot;]; [self string:mabstring appendString:kCTBaselineClassAttributeName value:(id)(kCTBaselineClassRoman) string:@&quot;kCTBaselineClassAttributeName&quot;]; [self string:mabstring appendString:kCTBaselineClassAttributeName value:(id)(kCTBaselineClassIdeographicCentered) string:@&quot;kCTBaselineClassAttributeName&quot;]; [self string:mabstring appendString:kCTBaselineClassAttributeName value:(id)(kCTBaselineClassIdeographicLow) string:@&quot;kCTBaselineClassAttributeName&quot;]; [self string:mabstring appendString:kCTBaselineClassAttributeName value:(id)(kCTBaselineClassIdeographicHigh) string:@&quot;kCTBaselineClassAttributeName&quot;]; [self string:mabstring appendString:kCTBaselineClassAttributeName value:(id)(kCTBaselineClassHanging) string:@&quot;kCTBaselineClassAttributeName&quot;]; [self string:mabstring appendString:kCTBaselineClassAttributeName value:(id)(kCTBaselineClassMath) string:@&quot;kCTBaselineClassAttributeName&quot;]; // [self string:mabstring appendString:kCTBaselineInfoAttributeName value:(id)([UIColor blueColor].CGColor) string:@&quot;kCTBaselineInfoAttributeName&quot;]; // [self string:mabstring appendString:kCTBaselineReferenceInfoAttributeName value:(id)([UIColor blueColor].CGColor) string:@&quot;kCTBaselineReferenceInfoAttributeName&quot;]; // [self string:mabstring appendString:kCTWritingDirectionAttributeName value:(id)([UIColor blueColor].CGColor) string:@&quot;kCTWritingDirectionAttributeName&quot;];// [self string:mabstring appendString:kCTRubyAnnotationAttributeName value:(id)([UIColor blueColor].CGColor) string:@&quot;kCTRubyAnnotationAttributeName&quot;]; CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetTextMatrix(context , CGAffineTransformIdentity); CGContextTranslateCTM(context , 0 ,self.bounds.size.height); CGContextScaleCTM(context, 1.0 ,-1.0); CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)mabstring); CGMutablePathRef Path = CGPathCreateMutable(); CGPathAddRect(Path, NULL ,CGRectMake(10 , 0 ,self.bounds.size.width-10 , self.bounds.size.height-60)); CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), Path, NULL); CTFrameDraw(frame, context);&#125;void CTRunDelegateDeallocateCallbackFunction (void * refCon )&#123; &#125;CGFloat CTRunDelegateGetAscentCallbackFunction (void * refCon )&#123; return 30;&#125;CGFloat CTRunDelegateGetDescentCallbackFunction (void * refCon )&#123; return 30;&#125;CGFloat CTRunDelegateGetWidthCallbackFunction(void * refCon )&#123; return 30;&#125; 结果截图 这个类就是 attString 配置类。 下面就是上面难点和不太清楚的地方攻关1234567891011121314151617181920212223242526272829kCTForegroundColorFromContextAttributeName 这个开关是关于是否用context 颜色来填充要是yes的话，kCTUnderlineStyleAttributeName 属性将失去效果。-(void)drawRect:(CGRect)rect&#123; CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetRGBStrokeColor(context, 0, 1, 0, 1); NSMutableAttributedString *mabstring = [[NSMutableAttributedString alloc]initWithString:@&quot;kCTForegroundColorFromContextAttributeName&quot;]; NSMutableDictionary * dic = [NSMutableDictionary dictionaryWithObject:(id)(@(YES)) forKey:(__bridge NSString *)kCTForegroundColorFromContextAttributeName]; [dic setObject:(id)([UIColor redColor].CGColor) forKey:(__bridge NSString *)kCTUnderlineColorAttributeName]; [dic setObject:(id)(@(kCTUnderlineStyleSingle)) forKey:(__bridge NSString *)kCTUnderlineStyleAttributeName]; [mabstring setAttributes:dic range:NSMakeRange(0, mabstring.length)]; CGContextSetTextMatrix(context , CGAffineTransformIdentity); CGContextTranslateCTM(context , 0 ,self.bounds.size.height); CGContextScaleCTM(context, 1.0 ,-1.0); CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)mabstring); CGMutablePathRef Path = CGPathCreateMutable(); CGPathAddRect(Path, NULL ,CGRectMake(10 , 0 ,self.bounds.size.width-10 , self.bounds.size.height-60)); CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), Path, NULL); CTFrameDraw(frame, context); &#125; 效果 同时设置CGContextRef 颜色 和 kCTUnderlineStyleAttributeName 属性值，而其动作用的是CGContextRef颜色。 1kCTLigatureAttributeName 连体字 没发现可用的字体 1kCTSuperscriptAttributeName 上标和下标 没看出效果 12345678910111213141516171819202122232425kCTUnderlineColorAttributeName 这个可以被 kCTForegroundColorFromContextAttributeName 属性影响， 要是该属性设置为yes 那么该属性就失效了补充： 下划线的还可以设置成一下样式：-(void)drawRect:(CGRect)rect&#123; CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetRGBStrokeColor(context, 0, 1, 0, 1); NSMutableAttributedString *mabstring = [[NSMutableAttributedString alloc]initWithString:@&quot;&quot;]; [self string:mabstring appendString:kCTUnderlineStyleAttributeName value:(id)(@(kCTUnderlineStyleDouble|kCTUnderlinePatternSolid)) string:@&quot;\\nkCTUnderlineStyleAttributeName&quot;]; [self string:mabstring appendString:kCTUnderlineStyleAttributeName value:(id)(@(kCTUnderlineStyleDouble|kCTUnderlinePatternDot)) string:@&quot;\\nkCTUnderlineStyleAttributeName&quot;]; [self string:mabstring appendString:kCTUnderlineStyleAttributeName value:(id)(@(kCTUnderlineStyleDouble|kCTUnderlinePatternDash)) string:@&quot;\\nkCTUnderlineStyleAttributeName&quot;]; [self string:mabstring appendString:kCTUnderlineStyleAttributeName value:(id)(@(kCTUnderlineStyleDouble|kCTUnderlinePatternDashDot)) string:@&quot;\\nkCTUnderlineStyleAttributeName&quot;]; [self string:mabstring appendString:kCTUnderlineStyleAttributeName value:(id)(@(kCTUnderlineStyleDouble|kCTUnderlinePatternDashDotDot)) string:@&quot;\\nkCTUnderlineStyleAttributeName&quot;]; CGContextSetTextMatrix(context , CGAffineTransformIdentity); CGContextTranslateCTM(context , 0 ,self.bounds.size.height); CGContextScaleCTM(context, 1.0 ,-1.0); CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)mabstring); CGMutablePathRef Path = CGPathCreateMutable(); CGPathAddRect(Path, NULL ,CGRectMake(10 , 0 ,self.bounds.size.width-10 , self.bounds.size.height-60)); CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), Path, NULL); CTFrameDraw(frame, context); &#125; 效果图： 1kCTHorizontalInVerticalFormsAttributeName 暂时不知道有啥用 1kCTGlyphInfoAttributeName 这个具体用法要看CTGlyphInfo.h 1kCTCharacterShapeAttributeName 9.0 以后被废弃了。不研究 1kCTLanguageAttributeName 暂时不知道干嘛用 1kCTBaselineClassAttributeName 没研究 1kCTBaselineInfoAttributeName 没研究 1kCTBaselineReferenceInfoAttributeName 没研究 1kCTWritingDirectionAttributeName 没研究 1234567891011121314151617181920212223kCTRubyAnnotationAttributeName 类似汉语拼音的注音-(void)drawRect:(CGRect)rect&#123; CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetRGBStrokeColor(context, 0, 1, 0, 1); NSMutableAttributedString *mabstring = [[NSMutableAttributedString alloc]initWithString:@&quot;kCTRubyAnnotationAttributeName&quot;]; CTRubyAnnotationRef rubyAnnotation =CTRubyAnnotationCreateWithAttributes(0, 0, 0, (__bridge CFStringRef)@&quot;nihoa&quot;, NULL); NSMutableDictionary * dic = [NSMutableDictionary dictionaryWithObject:(__bridge id)(rubyAnnotation) forKey:(__bridge NSString *)kCTRubyAnnotationAttributeName]; [mabstring setAttributes:dic range:NSMakeRange(0, mabstring.length)]; CGContextSetTextMatrix(context , CGAffineTransformIdentity); CGContextTranslateCTM(context , 0 ,self.bounds.size.height); CGContextScaleCTM(context, 1.0 ,-1.0); CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)mabstring); CGMutablePathRef Path = CGPathCreateMutable(); CGPathAddRect(Path, NULL ,CGRectMake(10 , 0 ,self.bounds.size.width-10 , self.bounds.size.height-60)); CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), Path, NULL); CTFrameDraw(frame, context); &#125; 效果如下: CTFontManager.h这个类是字体的管理者 1CTRegisterBundleFonts 这个key 如果在application bundle info dictionary 设置为yes 。CTFontManager 将该bundle的所有子文件夹的字体都注册。 运用场景不明。有待学完回来在重新测试。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553CFArrayRef CTFontManagerCopyAvailablePostScriptNames( void ) CT_AVAILABLE(10_6, 10_0); 翻译所有的postScript Names 所有的字体( &quot;.AlNilePUA&quot;, &quot;.AlNilePUA-Bold&quot;, &quot;.AppleColorEmojiUI&quot;, &quot;.AppleSDGothicNeoI-Bold&quot;, &quot;.AppleSDGothicNeoI-Light&quot;, &quot;.AppleSDGothicNeoI-Medium&quot;, &quot;.AppleSDGothicNeoI-Regular&quot;, &quot;.AppleSDGothicNeoI-SemiBold&quot;, &quot;.AppleSDGothicNeoI-Thin&quot;, &quot;.AppleSDGothicNeoI-UltraLight&quot;, &quot;.AppleSDGothicNeoW-Bold&quot;, &quot;.AppleSDGothicNeoW-Light&quot;, &quot;.AppleSDGothicNeoW-Medium&quot;, &quot;.AppleSDGothicNeoW-Regular&quot;, &quot;.AppleSDGothicNeoW-SemiBold&quot;, &quot;.AppleSDGothicNeoW-Thin&quot;, &quot;.AppleSDGothicNeoW-UltraLight&quot;, &quot;.DamascusPUA&quot;, &quot;.DamascusPUABold&quot;, &quot;.DamascusPUALight&quot;, &quot;.DamascusPUAMedium&quot;, &quot;.DamascusPUASemiBold&quot;, &quot;.FarahPUA&quot;, &quot;.GeezaProInterface&quot;, &quot;.GeezaProInterface-Bold&quot;, &quot;.GeezaProInterface-Light&quot;, &quot;.GeezaProPUA-Bold&quot;, &quot;.GeezaProPUA-Regular&quot;, &quot;.HelveticaLight&quot;, &quot;.HelveticaLight-Oblique&quot;, &quot;.HelveticaNeueATV&quot;, &quot;.HelveticaNeueInterface-Bold&quot;, &quot;.HelveticaNeueInterface-BoldItalic&quot;, &quot;.HelveticaNeueInterface-Heavy&quot;, &quot;.HelveticaNeueInterface-Italic&quot;, &quot;.HelveticaNeueInterface-ItalicM3&quot;, &quot;.HelveticaNeueInterface-Light&quot;, &quot;.HelveticaNeueInterface-M3&quot;, &quot;.HelveticaNeueInterface-MediumItalicP4&quot;, &quot;.HelveticaNeueInterface-MediumP4&quot;, &quot;.HelveticaNeueInterface-Regular&quot;, &quot;.HelveticaNeueInterface-Thin&quot;, &quot;.HelveticaNeueInterface-UltraLightP2&quot;, &quot;.HelveticaNeueUI&quot;, &quot;.HelveticaNeueUI-Bold&quot;, &quot;.HelveticaNeueUI-BoldItalic&quot;, &quot;.HelveticaNeueUI-Italic&quot;, &quot;.HiraKakuInterface-W1&quot;, &quot;.HiraKakuInterface-W2&quot;, &quot;.HiraKakuInterface-W3&quot;, &quot;.HiraKakuInterface-W6&quot;, &quot;.HiraKakuInterfaceWatch-W1&quot;, &quot;.HiraKakuInterfaceWatch-W2&quot;, &quot;.HiraKakuInterfaceWatch-W3&quot;, &quot;.HiraKakuInterfaceWatch-W6&quot;, &quot;.Keycaps-Keys&quot;, &quot;.Keycaps-Light&quot;, &quot;.Keycaps-Popups&quot;, &quot;.Keycaps-Thin&quot;, &quot;.KeycapsA-Keys&quot;, &quot;.KeycapsA-Popups&quot;, &quot;.KeycapsB-Keys&quot;, &quot;.KeycapsB-Popups&quot;, &quot;.KeycapsPad-Keys&quot;, &quot;.KeycapsPad-Light&quot;, &quot;.KeycapsPadA-Keys&quot;, &quot;.PhoneFallback&quot;, &quot;.PhoneKeyCaps&quot;, &quot;.PhoneKeyCapsThree&quot;, &quot;.PingFangHK-Light&quot;, &quot;.PingFangHK-Medium&quot;, &quot;.PingFangHK-Regular&quot;, &quot;.PingFangHK-Semibold&quot;, &quot;.PingFangHK-Thin&quot;, &quot;.PingFangHK-Ultralight&quot;, &quot;.PingFangSC-Light&quot;, &quot;.PingFangSC-Medium&quot;, &quot;.PingFangSC-Regular&quot;, &quot;.PingFangSC-Semibold&quot;, &quot;.PingFangSC-Thin&quot;, &quot;.PingFangSC-Ultralight&quot;, &quot;.PingFangTC-Light&quot;, &quot;.PingFangTC-Medium&quot;, &quot;.PingFangTC-Regular&quot;, &quot;.PingFangTC-Semibold&quot;, &quot;.PingFangTC-Thin&quot;, &quot;.PingFangTC-Ultralight&quot;, &quot;.SFCompactDisplay-Black&quot;, &quot;.SFCompactDisplay-Bold&quot;, &quot;.SFCompactDisplay-Heavy&quot;, &quot;.SFCompactDisplay-Light&quot;, &quot;.SFCompactDisplay-Medium&quot;, &quot;.SFCompactDisplay-Regular&quot;, &quot;.SFCompactDisplay-Semibold&quot;, &quot;.SFCompactDisplay-Thin&quot;, &quot;.SFCompactDisplay-Ultralight&quot;, &quot;.SFCompactRounded-Black&quot;, &quot;.SFCompactRounded-Bold&quot;, &quot;.SFCompactRounded-Heavy&quot;, &quot;.SFCompactRounded-Light&quot;, &quot;.SFCompactRounded-Medium&quot;, &quot;.SFCompactRounded-Regular&quot;, &quot;.SFCompactRounded-Semibold&quot;, &quot;.SFCompactRounded-Thin&quot;, &quot;.SFCompactRounded-Ultralight&quot;, &quot;.SFCompactText-Bold&quot;, &quot;.SFCompactText-BoldG1&quot;, &quot;.SFCompactText-BoldG2&quot;, &quot;.SFCompactText-BoldG3&quot;, &quot;.SFCompactText-BoldItalic&quot;, &quot;.SFCompactText-BoldItalicG1&quot;, &quot;.SFCompactText-BoldItalicG2&quot;, &quot;.SFCompactText-BoldItalicG3&quot;, &quot;.SFCompactText-Heavy&quot;, &quot;.SFCompactText-HeavyItalic&quot;, &quot;.SFCompactText-Italic&quot;, &quot;.SFCompactText-ItalicG1&quot;, &quot;.SFCompactText-ItalicG2&quot;, &quot;.SFCompactText-ItalicG3&quot;, &quot;.SFCompactText-Light&quot;, &quot;.SFCompactText-LightItalic&quot;, &quot;.SFCompactText-Medium&quot;, &quot;.SFCompactText-MediumItalic&quot;, &quot;.SFCompactText-Regular&quot;, &quot;.SFCompactText-RegularG1&quot;, &quot;.SFCompactText-RegularG2&quot;, &quot;.SFCompactText-RegularG3&quot;, &quot;.SFCompactText-Semibold&quot;, &quot;.SFCompactText-SemiboldItalic&quot;, &quot;.SFUIDisplay&quot;, &quot;.SFUIDisplay-Black&quot;, &quot;.SFUIDisplay-Bold&quot;, &quot;.SFUIDisplay-Heavy&quot;, &quot;.SFUIDisplay-Light&quot;, &quot;.SFUIDisplay-Medium&quot;, &quot;.SFUIDisplay-Semibold&quot;, &quot;.SFUIDisplay-Thin&quot;, &quot;.SFUIDisplay-Ultralight&quot;, &quot;.SFUIDisplayCondensed-Black&quot;, &quot;.SFUIDisplayCondensed-Bold&quot;, &quot;.SFUIDisplayCondensed-Heavy&quot;, &quot;.SFUIDisplayCondensed-Light&quot;, &quot;.SFUIDisplayCondensed-Medium&quot;, &quot;.SFUIDisplayCondensed-Regular&quot;, &quot;.SFUIDisplayCondensed-Semibold&quot;, &quot;.SFUIDisplayCondensed-Thin&quot;, &quot;.SFUIDisplayCondensed-Ultralight&quot;, &quot;.SFUIText&quot;, &quot;.SFUIText-Bold&quot;, &quot;.SFUIText-BoldG1&quot;, &quot;.SFUIText-BoldG2&quot;, &quot;.SFUIText-BoldG3&quot;, &quot;.SFUIText-BoldItalic&quot;, &quot;.SFUIText-BoldItalicG1&quot;, &quot;.SFUIText-BoldItalicG2&quot;, &quot;.SFUIText-BoldItalicG3&quot;, &quot;.SFUIText-Heavy&quot;, &quot;.SFUIText-HeavyItalic&quot;, &quot;.SFUIText-Italic&quot;, &quot;.SFUIText-ItalicG1&quot;, &quot;.SFUIText-ItalicG2&quot;, &quot;.SFUIText-ItalicG3&quot;, &quot;.SFUIText-Light&quot;, &quot;.SFUIText-LightItalic&quot;, &quot;.SFUIText-Medium&quot;, &quot;.SFUIText-MediumItalic&quot;, &quot;.SFUIText-RegularG1&quot;, &quot;.SFUIText-RegularG2&quot;, &quot;.SFUIText-RegularG3&quot;, &quot;.SFUIText-Semibold&quot;, &quot;.SFUIText-SemiboldItalic&quot;, &quot;.SFUITextCondensed-Bold&quot;, &quot;.SFUITextCondensed-Heavy&quot;, &quot;.SFUITextCondensed-Light&quot;, &quot;.SFUITextCondensed-Medium&quot;, &quot;.SFUITextCondensed-Regular&quot;, &quot;.SFUITextCondensed-Semibold&quot;, &quot;.SavoyeLetPlainCC&quot;, &quot;.SukhumvitSetUI-Bold&quot;, &quot;.SukhumvitSetUI-Light&quot;, &quot;.SukhumvitSetUI-Medium&quot;, AcademyEngravedLetPlain, AlNile, &quot;AlNile-Bold&quot;, AmericanTypewriter, &quot;AmericanTypewriter-Bold&quot;, &quot;AmericanTypewriter-Condensed&quot;, &quot;AmericanTypewriter-CondensedBold&quot;, &quot;AmericanTypewriter-CondensedLight&quot;, &quot;AmericanTypewriter-Light&quot;, &quot;AmericanTypewriter-Semibold&quot;, AppleColorEmoji, AppleGothic, &quot;AppleSDGothicNeo-Bold&quot;, &quot;AppleSDGothicNeo-Light&quot;, &quot;AppleSDGothicNeo-Medium&quot;, &quot;AppleSDGothicNeo-Regular&quot;, &quot;AppleSDGothicNeo-SemiBold&quot;, &quot;AppleSDGothicNeo-Thin&quot;, &quot;AppleSDGothicNeo-UltraLight&quot;, &quot;Arial-BoldItalicMT&quot;, &quot;Arial-BoldMT&quot;, &quot;Arial-ItalicMT&quot;, ArialHebrew, &quot;ArialHebrew-Bold&quot;, &quot;ArialHebrew-Light&quot;, ArialMT, ArialRoundedMTBold, &quot;Asphalt-Medium&quot;, &quot;Athelas-Bold&quot;, &quot;Athelas-BoldItalic&quot;, &quot;Athelas-Italic&quot;, &quot;Athelas-Regular&quot;, &quot;Avenir-Black&quot;, &quot;Avenir-BlackOblique&quot;, &quot;Avenir-Book&quot;, &quot;Avenir-BookOblique&quot;, &quot;Avenir-Heavy&quot;, &quot;Avenir-HeavyOblique&quot;, &quot;Avenir-Light&quot;, &quot;Avenir-LightOblique&quot;, &quot;Avenir-Medium&quot;, &quot;Avenir-MediumOblique&quot;, &quot;Avenir-Oblique&quot;, &quot;Avenir-Roman&quot;, &quot;AvenirNext-Bold&quot;, &quot;AvenirNext-BoldItalic&quot;, &quot;AvenirNext-DemiBold&quot;, &quot;AvenirNext-DemiBoldItalic&quot;, &quot;AvenirNext-Heavy&quot;, &quot;AvenirNext-HeavyItalic&quot;, &quot;AvenirNext-Italic&quot;, &quot;AvenirNext-Medium&quot;, &quot;AvenirNext-MediumItalic&quot;, &quot;AvenirNext-Regular&quot;, &quot;AvenirNext-UltraLight&quot;, &quot;AvenirNext-UltraLightItalic&quot;, &quot;AvenirNextCondensed-Bold&quot;, &quot;AvenirNextCondensed-BoldItalic&quot;, &quot;AvenirNextCondensed-DemiBold&quot;, &quot;AvenirNextCondensed-DemiBoldItalic&quot;, &quot;AvenirNextCondensed-Heavy&quot;, &quot;AvenirNextCondensed-HeavyItalic&quot;, &quot;AvenirNextCondensed-Italic&quot;, &quot;AvenirNextCondensed-Medium&quot;, &quot;AvenirNextCondensed-MediumItalic&quot;, &quot;AvenirNextCondensed-Regular&quot;, &quot;AvenirNextCondensed-UltraLight&quot;, &quot;AvenirNextCondensed-UltraLightItalic&quot;, &quot;Balega-Regular&quot;, Baskerville, &quot;Baskerville-Bold&quot;, &quot;Baskerville-BoldItalic&quot;, &quot;Baskerville-Italic&quot;, &quot;Baskerville-SemiBold&quot;, &quot;Baskerville-SemiBoldItalic&quot;, BebasNeue, BodoniOrnamentsITCTT, &quot;BodoniSvtyTwoITCTT-Bold&quot;, &quot;BodoniSvtyTwoITCTT-Book&quot;, &quot;BodoniSvtyTwoITCTT-BookIta&quot;, &quot;BodoniSvtyTwoOSITCTT-Bold&quot;, &quot;BodoniSvtyTwoOSITCTT-Book&quot;, &quot;BodoniSvtyTwoOSITCTT-BookIt&quot;, &quot;BodoniSvtyTwoSCITCTT-Book&quot;, &quot;BradleyHandITCTT-Bold&quot;, &quot;ChalkboardSE-Bold&quot;, &quot;ChalkboardSE-Light&quot;, &quot;ChalkboardSE-Regular&quot;, Chalkduster, &quot;Charter-Black&quot;, &quot;Charter-BlackItalic&quot;, &quot;Charter-Bold&quot;, &quot;Charter-BoldItalic&quot;, &quot;Charter-Italic&quot;, &quot;Charter-Roman&quot;, Cochin, &quot;Cochin-Bold&quot;, &quot;Cochin-BoldItalic&quot;, &quot;Cochin-Italic&quot;, Copperplate, &quot;Copperplate-Bold&quot;, &quot;Copperplate-Light&quot;, Courier, &quot;Courier-Bold&quot;, &quot;Courier-BoldOblique&quot;, &quot;Courier-Oblique&quot;, &quot;CourierNewPS-BoldItalicMT&quot;, &quot;CourierNewPS-BoldMT&quot;, &quot;CourierNewPS-ItalicMT&quot;, CourierNewPSMT, DBLCDTempBlack, &quot;DINAlternate-Bold&quot;, &quot;DINCondensed-Bold&quot;, Damascus, DamascusBold, DamascusLight, DamascusMedium, DamascusSemiBold, &quot;DearJoeFour-SmallSemibold&quot;, DevanagariSangamMN, &quot;DevanagariSangamMN-Bold&quot;, Didot, &quot;Didot-Bold&quot;, &quot;Didot-Italic&quot;, DiwanMishafi, &quot;Druk-HeavyItalic&quot;, EuphemiaUCAS, &quot;EuphemiaUCAS-Bold&quot;, &quot;EuphemiaUCAS-Italic&quot;, &quot;FaktSlabStencilPro-Medium&quot;, Farah, &quot;Futura-Bold&quot;, &quot;Futura-CondensedExtraBold&quot;, &quot;Futura-CondensedMedium&quot;, &quot;Futura-Medium&quot;, &quot;Futura-MediumItalic&quot;, GeezaPro, &quot;GeezaPro-Bold&quot;, Georgia, &quot;Georgia-Bold&quot;, &quot;Georgia-BoldItalic&quot;, &quot;Georgia-Italic&quot;, GillSans, &quot;GillSans-Bold&quot;, &quot;GillSans-BoldItalic&quot;, &quot;GillSans-Italic&quot;, &quot;GillSans-Light&quot;, &quot;GillSans-LightItalic&quot;, &quot;GillSans-SemiBold&quot;, &quot;GillSans-SemiBoldItalic&quot;, &quot;GillSans-UltraBold&quot;, GujaratiSangamMN, &quot;GujaratiSangamMN-Bold&quot;, GurmukhiMN, &quot;GurmukhiMN-Bold&quot;, Helvetica, &quot;Helvetica-Bold&quot;, &quot;Helvetica-BoldOblique&quot;, &quot;Helvetica-Light&quot;, &quot;Helvetica-LightOblique&quot;, &quot;Helvetica-Oblique&quot;, HelveticaLTMM, HelveticaNeue, &quot;HelveticaNeue-Bold&quot;, &quot;HelveticaNeue-BoldItalic&quot;, &quot;HelveticaNeue-CondensedBlack&quot;, &quot;HelveticaNeue-CondensedBold&quot;, &quot;HelveticaNeue-Italic&quot;, &quot;HelveticaNeue-Light&quot;, &quot;HelveticaNeue-LightItalic&quot;, &quot;HelveticaNeue-Medium&quot;, &quot;HelveticaNeue-MediumItalic&quot;, &quot;HelveticaNeue-Thin&quot;, &quot;HelveticaNeue-ThinItalic&quot;, &quot;HelveticaNeue-UltraLight&quot;, &quot;HelveticaNeue-UltraLightItalic&quot;, &quot;HiraKakuProN-W3&quot;, &quot;HiraKakuProN-W6&quot;, &quot;HiraMinProN-W3&quot;, &quot;HiraMinProN-W6&quot;, &quot;HiraginoSans-W3&quot;, &quot;HiraginoSans-W6&quot;, &quot;HoeflerText-Black&quot;, &quot;HoeflerText-BlackItalic&quot;, &quot;HoeflerText-Italic&quot;, &quot;HoeflerText-Regular&quot;, &quot;IowanOldStyle-Bold&quot;, &quot;IowanOldStyle-BoldItalic&quot;, &quot;IowanOldStyle-Italic&quot;, &quot;IowanOldStyle-Roman&quot;, &quot;JournalSansNew-Inline&quot;, Kailasa, &quot;Kailasa-Bold&quot;, KannadaSangamMN, &quot;KannadaSangamMN-Bold&quot;, KhmerSangamMN, &quot;KohinoorBangla-Light&quot;, &quot;KohinoorBangla-Regular&quot;, &quot;KohinoorBangla-Semibold&quot;, &quot;KohinoorDevanagari-Light&quot;, &quot;KohinoorDevanagari-Regular&quot;, &quot;KohinoorDevanagari-Semibold&quot;, &quot;KohinoorTelugu-Light&quot;, &quot;KohinoorTelugu-Medium&quot;, &quot;KohinoorTelugu-Regular&quot;, LaoSangamMN, LastResort, &quot;LockClock-Light&quot;, MalayalamSangamMN, &quot;MalayalamSangamMN-Bold&quot;, &quot;Marion-Bold&quot;, &quot;Marion-Italic&quot;, &quot;Marion-Regular&quot;, &quot;MarkerFelt-Thin&quot;, &quot;MarkerFelt-Wide&quot;, &quot;Menlo-Bold&quot;, &quot;Menlo-BoldItalic&quot;, &quot;Menlo-Italic&quot;, &quot;Menlo-Regular&quot;, MyanmarSangamMN, &quot;MyanmarSangamMN-Bold&quot;, &quot;Noteworthy-Bold&quot;, &quot;Noteworthy-Light&quot;, NotoSansAvestan, NotoSansBalinese, NotoSansBamum, NotoSansBatak, NotoSansBrahmi, NotoSansBuginese, NotoSansBuhid, NotoSansCarian, NotoSansCham, NotoSansCoptic, NotoSansCuneiform, NotoSansCypriot, NotoSansEgyptianHieroglyphs, NotoSansGlagolitic, NotoSansGothic, NotoSansHanunoo, NotoSansImperialAramaic, NotoSansInscriptionalPahlavi, NotoSansInscriptionalParthian, NotoSansJavanese, NotoSansKaithi, NotoSansKayahLi, NotoSansKharoshthi, NotoSansLepcha, NotoSansLimbu, NotoSansLinearB, NotoSansLisu, NotoSansLycian, NotoSansLydian, NotoSansMandaic, NotoSansMeeteiMayek, NotoSansMongolian, NotoSansNKo, NotoSansNewTaiLue, NotoSansOgham, NotoSansOlChiki, NotoSansOldItalic, NotoSansOldPersian, NotoSansOldSouthArabian, NotoSansOldTurkic, NotoSansOsmanya, NotoSansPhagsPa, NotoSansPhoenician, NotoSansRejang, NotoSansRunic, NotoSansSamaritan, NotoSansSaurashtra, NotoSansShavian, NotoSansSundanese, NotoSansSylotiNagri, NotoSansSyriacEastern, NotoSansTagalog, NotoSansTagbanwa, NotoSansTaiLe, NotoSansTaiTham, NotoSansTaiViet, NotoSansThaana, NotoSansTifinagh, NotoSansUgaritic, NotoSansVai, NotoSansYi, &quot;Optima-Bold&quot;, &quot;Optima-BoldItalic&quot;, &quot;Optima-ExtraBlack&quot;, &quot;Optima-Italic&quot;, &quot;Optima-Regular&quot;, OriyaSangamMN, &quot;OriyaSangamMN-Bold&quot;, &quot;Palatino-Bold&quot;, &quot;Palatino-BoldItalic&quot;, &quot;Palatino-Italic&quot;, &quot;Palatino-Roman&quot;, Papyrus, &quot;Papyrus-Condensed&quot;, PartyLetPlain, PhoneKeyCapsTwo, PhonepadTwo, &quot;PingFangHK-Light&quot;, &quot;PingFangHK-Medium&quot;, &quot;PingFangHK-Regular&quot;, &quot;PingFangHK-Semibold&quot;, &quot;PingFangHK-Thin&quot;, &quot;PingFangHK-Ultralight&quot;, &quot;PingFangSC-Light&quot;, &quot;PingFangSC-Medium&quot;, &quot;PingFangSC-Regular&quot;, &quot;PingFangSC-Semibold&quot;, &quot;PingFangSC-Thin&quot;, &quot;PingFangSC-Ultralight&quot;, &quot;PingFangTC-Light&quot;, &quot;PingFangTC-Medium&quot;, &quot;PingFangTC-Regular&quot;, &quot;PingFangTC-Semibold&quot;, &quot;PingFangTC-Thin&quot;, &quot;PingFangTC-Ultralight&quot;, &quot;Rockwell-Bold&quot;, SavoyeLetPlain, &quot;Scheme-Bold&quot;, Seravek, &quot;Seravek-Bold&quot;, &quot;Seravek-BoldItalic&quot;, &quot;Seravek-ExtraLight&quot;, &quot;Seravek-ExtraLightItalic&quot;, &quot;Seravek-Italic&quot;, &quot;Seravek-Light&quot;, &quot;Seravek-LightItalic&quot;, &quot;Seravek-Medium&quot;, &quot;Seravek-MediumItalic&quot;, &quot;SignPainter-HouseScriptSemibold&quot;, SinhalaSangamMN, &quot;SinhalaSangamMN-Bold&quot;, SnellRoundhand, &quot;SnellRoundhand-Black&quot;, &quot;SnellRoundhand-Bold&quot;, &quot;Superclarendon-Black&quot;, &quot;Superclarendon-BlackItalic&quot;, &quot;Superclarendon-Bold&quot;, &quot;Superclarendon-BoldItalic&quot;, &quot;Superclarendon-Italic&quot;, &quot;Superclarendon-Light&quot;, &quot;Superclarendon-LightItalic&quot;, &quot;Superclarendon-Regular&quot;, Symbol, TamilSangamMN, &quot;TamilSangamMN-Bold&quot;, &quot;TheHandSerif-Semibold&quot;, Thonburi, &quot;Thonburi-Bold&quot;, &quot;Thonburi-Light&quot;, TimesLTMM, &quot;TimesNewRomanPS-BoldItalicMT&quot;, &quot;TimesNewRomanPS-BoldMT&quot;, &quot;TimesNewRomanPS-ItalicMT&quot;, TimesNewRomanPSMT, &quot;Trebuchet-BoldItalic&quot;, TrebuchetMS, &quot;TrebuchetMS-Bold&quot;, &quot;TrebuchetMS-Italic&quot;, Verdana, &quot;Verdana-Bold&quot;, &quot;Verdana-BoldItalic&quot;, &quot;Verdana-Italic&quot;, ZapfDingbatsITC, Zapfino) count 548 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199CFArrayRef CTFontManagerCopyAvailableFontFamilyNames( void ) CT_AVAILABLE(10_6, 10_0); 所有的 fontFamilyName结果( &quot;.Al Nile PUA&quot;, &quot;.Apple Color Emoji UI&quot;, &quot;.Apple SD Gothic NeoI&quot;, &quot;.Apple SD Gothic NeoW&quot;, &quot;.Damascus PUA&quot;, &quot;.Farah PUA&quot;, &quot;.Geeza Pro Interface&quot;, &quot;.Geeza Pro PUA&quot;, &quot;.Helvetica Light&quot;, &quot;.Helvetica LT MM&quot;, &quot;.Helvetica Neue ATV&quot;, &quot;.Helvetica Neue Interface&quot;, &quot;.Helvetica NeueUI&quot;, &quot;.Hiragino Kaku Gothic Interface&quot;, &quot;.Hiragino Kaku Gothic InterfaceWatch&quot;, &quot;.Keycaps&quot;, &quot;.Keycaps A&quot;, &quot;.Keycaps B&quot;, &quot;.Keycaps Pad&quot;, &quot;.Keycaps Pad A&quot;, &quot;.LastResort&quot;, &quot;.Lock Clock&quot;, &quot;.PhoneFallback&quot;, &quot;.PhoneKeyCaps&quot;, &quot;.PhoneKeyCapsThree&quot;, &quot;.PhoneKeyCapsTwo&quot;, &quot;.PhonepadTwo&quot;, &quot;.PingFang HK&quot;, &quot;.PingFang SC&quot;, &quot;.PingFang TC&quot;, &quot;.Savoye LET CC.&quot;, &quot;.SF Compact Display&quot;, &quot;.SF Compact Rounded&quot;, &quot;.SF Compact Text&quot;, &quot;.SF UI Display&quot;, &quot;.SF UI Display Condensed&quot;, &quot;.SF UI Text&quot;, &quot;.SF UI Text Condensed&quot;, &quot;.Sukhumvit Set UI&quot;, &quot;.Times LT MM&quot;, &quot;Academy Engraved LET&quot;, &quot;Al Nile&quot;, &quot;American Typewriter&quot;, Arial, &quot;Arial Hebrew&quot;, &quot;Arial Rounded MT Bold&quot;, Asphalt, Athelas, Avenir, &quot;Avenir Next&quot;, &quot;Avenir Next Condensed&quot;, Balega, Baskerville, &quot;Bebas Neue&quot;, &quot;Bodoni 72&quot;, &quot;Bodoni 72 Oldstyle&quot;, &quot;Bodoni 72 Smallcaps&quot;, &quot;Bodoni Ornaments&quot;, &quot;Bradley Hand&quot;, &quot;Chalkboard SE&quot;, Chalkduster, Charter, Cochin, Copperplate, Courier, &quot;Courier New&quot;, Damascus, &quot;DB LCD Temp&quot;, &quot;Dear Joe Four&quot;, &quot;Devanagari Sangam MN&quot;, Didot, &quot;DIN Alternate&quot;, &quot;DIN Condensed&quot;, Druk, &quot;Euphemia UCAS&quot;, &quot;Fakt Slab Stencil Pro&quot;, Farah, Futura, &quot;Geeza Pro&quot;, Georgia, &quot;Gill Sans&quot;, &quot;Gujarati Sangam MN&quot;, &quot;Gurmukhi MN&quot;, Helvetica, &quot;Helvetica Neue&quot;, &quot;Hiragino Kaku Gothic ProN&quot;, &quot;Hiragino Mincho ProN&quot;, &quot;Hiragino Sans&quot;, &quot;Hoefler Text&quot;, &quot;Iowan Old Style&quot;, &quot;Journal Sans New&quot;, Kailasa, &quot;Kannada Sangam MN&quot;, &quot;Khmer Sangam MN&quot;, &quot;Kohinoor Bangla&quot;, &quot;Kohinoor Devanagari&quot;, &quot;Kohinoor Telugu&quot;, &quot;Lao Sangam MN&quot;, &quot;Malayalam Sangam MN&quot;, Marion, &quot;Marker Felt&quot;, Menlo, Mishafi, &quot;Myanmar Sangam MN&quot;, Noteworthy, &quot;Noto Sans Avestan&quot;, &quot;Noto Sans Balinese&quot;, &quot;Noto Sans Bamum&quot;, &quot;Noto Sans Batak&quot;, &quot;Noto Sans Brahmi&quot;, &quot;Noto Sans Buginese&quot;, &quot;Noto Sans Buhid&quot;, &quot;Noto Sans Carian&quot;, &quot;Noto Sans Cham&quot;, &quot;Noto Sans Coptic&quot;, &quot;Noto Sans Cuneiform&quot;, &quot;Noto Sans Cypriot&quot;, &quot;Noto Sans Egyptian Hieroglyphs&quot;, &quot;Noto Sans Glagolitic&quot;, &quot;Noto Sans Gothic&quot;, &quot;Noto Sans Hanunoo&quot;, &quot;Noto Sans Imperial Aramaic&quot;, &quot;Noto Sans Inscriptional Pahlavi&quot;, &quot;Noto Sans Inscriptional Parthian&quot;, &quot;Noto Sans Javanese&quot;, &quot;Noto Sans Kaithi&quot;, &quot;Noto Sans Kayah Li&quot;, &quot;Noto Sans Kharoshthi&quot;, &quot;Noto Sans Lepcha&quot;, &quot;Noto Sans Limbu&quot;, &quot;Noto Sans Linear B&quot;, &quot;Noto Sans Lisu&quot;, &quot;Noto Sans Lycian&quot;, &quot;Noto Sans Lydian&quot;, &quot;Noto Sans Mandaic&quot;, &quot;Noto Sans Meetei Mayek&quot;, &quot;Noto Sans Mongolian&quot;, &quot;Noto Sans New Tai Lue&quot;, &quot;Noto Sans NKo&quot;, &quot;Noto Sans Ogham&quot;, &quot;Noto Sans Ol Chiki&quot;, &quot;Noto Sans Old Italic&quot;, &quot;Noto Sans Old Persian&quot;, &quot;Noto Sans Old South Arabian&quot;, &quot;Noto Sans Old Turkic&quot;, &quot;Noto Sans Osmanya&quot;, &quot;Noto Sans Phags Pa&quot;, &quot;Noto Sans Phoenician&quot;, &quot;Noto Sans Rejang&quot;, &quot;Noto Sans Runic&quot;, &quot;Noto Sans Samaritan&quot;, &quot;Noto Sans Saurashtra&quot;, &quot;Noto Sans Shavian&quot;, &quot;Noto Sans Sundanese&quot;, &quot;Noto Sans Syloti Nagri&quot;, &quot;Noto Sans Syriac Eastern&quot;, &quot;Noto Sans Tagalog&quot;, &quot;Noto Sans Tagbanwa&quot;, &quot;Noto Sans Tai Le&quot;, &quot;Noto Sans Tai Tham&quot;, &quot;Noto Sans Tai Viet&quot;, &quot;Noto Sans Thaana&quot;, &quot;Noto Sans Tifinagh&quot;, &quot;Noto Sans Ugaritic&quot;, &quot;Noto Sans Vai&quot;, &quot;Noto Sans Yi&quot;, Optima, &quot;Oriya Sangam MN&quot;, Palatino, Papyrus, &quot;Party LET&quot;, &quot;PingFang HK&quot;, &quot;PingFang SC&quot;, &quot;PingFang TC&quot;, Rockwell, &quot;Savoye LET&quot;, Scheme, Seravek, SignPainter, &quot;Sinhala Sangam MN&quot;, &quot;Snell Roundhand&quot;, Superclarendon, Symbol, &quot;Tamil Sangam MN&quot;, &quot;The Hand Serif&quot;, Thonburi, &quot;Times New Roman&quot;, &quot;Trebuchet MS&quot;, Verdana, &quot;Zapf Dingbats&quot;, Zapfino, &quot;Apple Color Emoji&quot;, &quot;Apple SD Gothic Neo&quot;, AppleGothic) count 194 12345678CFArrayRef CTFontManagerCopyAvailableFontURLs( void ) CT_AVAILABLE_MAC(10_6); mac 专用CFComparisonResult CTFontManagerCompareFontFamilyNames( const void * family1, const void * family2, void * __nullable context ) CT_AVAILABLE_MAC(10_6); mac专用 123CFArrayRef __nullable CTFontManagerCreateFontDescriptorsFromURL( CFURLRef fileURL ) CT_AVAILABLE(10_6, 7_0); 这个不会用 ，不知道fileURL怎么来 123CTFontDescriptorRef __nullable CTFontManagerCreateFontDescriptorFromData( CFDataRef data ) 这个也不会用，不知道data怎么来 12345678typedef CF_ENUM(uint32_t, CTFontManagerScope) &#123; kCTFontManagerScopeNone = 0, kCTFontManagerScopeProcess = 1, kCTFontManagerScopeUser = 2, /* not supported in iOS */ kCTFontManagerScopeSession = 3 /* not supported in iOS */&#125;;这个权限 ios kCTFontManagerScopeProcess 能用 12345bool CTFontManagerRegisterFontsForURL( CFURLRef fontURL, CTFontManagerScope scope, CFErrorRef * error ) 这个fontURL 不知道怎么来 12345bool CTFontManagerUnregisterFontsForURL( CFURLRef fontURL, CTFontManagerScope scope, CFErrorRef * error ) CT_AVAILABLE(10_6, 4_1); 这个fontRUL 不知道怎么来 123bool CTFontManagerRegisterGraphicsFont( CGFontRef font, CFErrorRef * error ) CT_AVAILABLE(10_8, 4_1); 123bool CTFontManagerUnregisterGraphicsFont( CGFontRef font, CFErrorRef * error ) CT_AVAILABLE(10_8, 4_1) 1234bool CTFontManagerRegisterFontsForURLs( CFArrayRef fontURLs, CTFontManagerScope scope, CFArrayRef __nullable * __nullable errors ) 1234bool CTFontManagerUnregisterFontsForURLs( CFArrayRef fontURLs, CTFontManagerScope scope, CFArrayRef __nullable * __nullable errors ) 1234567891011121314151617181920212223242526272829void CTFontManagerEnableFontDescriptors( CFArrayRef descriptors, bool enable ) CT_AVAILABLE_MAC(10_6); mac 有效 CTFontManagerScope CTFontManagerGetScopeForURL(CFURLRef fontURL ) CT_AVAILABLE_MAC(10_6);mac 有效bool CTFontManagerIsSupportedFont( CFURLRef fontURL ) CT_AVAILABLE_MAC(10_6)mac 有效CFRunLoopSourceRef __nullable CTFontManagerCreateFontRequestRunLoopSource( CFIndex sourceOrder, CFArrayRef (^createMatchesCallback)(CFDictionaryRef requestAttributes, pid_t requestingProcess)) CT_AVAILABLE_MAC(10_6);mac 有效CT_EXPORT const CFStringRef kCTFontManagerBundleIdentifier CT_AVAILABLE_MAC(10_6);mac bundlevoid CTFontManagerSetAutoActivationSetting( CFStringRef __nullable bundleIdentifier, CTFontManagerAutoActivationSetting setting ) CT_AVAILABLE_MAC(10_6); mac 有效CTFontManagerAutoActivationSetting CTFontManagerGetAutoActivationSetting( CFStringRef __nullable bundleIdentifier ) CT_AVAILABLE_MAC(10_6); mac 有效 1CT_EXPORT const CFStringRef kCTFontManagerRegisteredFontsChangedNotification CT_AVAILABLE(10_6, 7_0); 字体注册变化通知。 该类是用来manger 字体的，但是不知道有啥用。 CTFontManagerError.h123456789101112CT_EXPORT const CFStringRef kCTFontManagerErrorDomain CT_AVAILABLE(10_6, 3_2);CT_EXPORT const CFStringRef kCTFontManagerErrorFontURLsKey CT_AVAILABLE(10_6, 3_2);typedef CF_ENUM(CFIndex, CTFontManagerError) &#123; kCTFontManagerErrorFileNotFound = 101, kCTFontManagerErrorInsufficientPermissions = 102, kCTFontManagerErrorUnrecognizedFormat = 103, kCTFontManagerErrorInvalidFontData = 104, kCTFontManagerErrorAlreadyRegistered = 105, kCTFontManagerErrorNotRegistered = 201, kCTFontManagerErrorInUse = 202, kCTFontManagerErrorSystemRequired = 203,&#125;; CTFontTraits.h该类是字体特征，暂时没看api CTFontCollection.hCTFontDescriptor.h该类从以下四个方面来学习。 1.Descriptor Types1CFTypeID CTFontDescriptorGetTypeID( void ) CT_AVAILABLE(10_5, 3_2); 2.Descriptor Constants ke’y value 解释 kCTFontURLAttribute CFURLRef 通过 descriptor 访问字体的url kCTFontNameAttribute CFStringRef 先从 PostScript arr 中找， 没发现在从 family 数字找，没发现 用 display name 。， 如果还是从字体列表中没找到，默认返回 Helvetica 字体 kCTFontDisplayNameAttribute CFStringRef 这个返回display name 大多数是 the full name。 kCTFontFamilyNameAttribute CFStringRef 返回 family name kCTFontStyleNameAttribute CFStringRef 返回 the style name of the font。代表设计者对该字体样式的描述。 kCTFontTraitsAttribute CFDictionaryRef 返回改字体的特性 traits 字典。 kCTFontVariationAttribute CFDictionaryRef 不知道啥用 kCTFontSizeAttribute CFNumberRef 返回字体的大小 kCTFontMatrixAttribute CFDataRef 该data是 CGAffineTransform信息 kCTFontCascadeListAttribute CFArrayRef 级联表格数组，具体干嘛的不知道。看结果在说 kCTFontCharacterSetAttribute CFCharacterSetRef kCTFontLanguagesAttribute CFArrayRef kCTFontBaselineAdjustAttribute CFNumberRef kCTFontMacintoshEncodingsAttribute CFNumberRef kCTFontFeaturesAttribute CFArrayRef kCTFontFeatureSettingsAttribute kCTFontFixedAdvanceAttribute CFNumberRef kCTFontOrientationAttribute CFNumberRef kCTFontFormatAttribute CFNumber kCTFontRegistrationScopeAttribute CTFontManagerScope kCTFontPriorityAttribute kCTFontEnabledAttribute kCTFontDownloadableAttribute kCTFontDownloadedAttribute 123456789typedef CF_ENUM(uint32_t, CTFontOrientation) &#123; kCTFontOrientationDefault CT_ENUM_AVAILABLE(10_8, 6_0) = 0, kCTFontOrientationHorizontal CT_ENUM_AVAILABLE(10_8, 6_0) = 1, kCTFontOrientationVertical CT_ENUM_AVAILABLE(10_8, 6_0) = 2, kCTFontDefaultOrientation CT_ENUM_DEPRECATED(10_5, 10_11, 3_2, 9_0) = kCTFontOrientationDefault, kCTFontHorizontalOrientation CT_ENUM_DEPRECATED(10_5, 10_11, 3_2, 9_0) = kCTFontOrientationHorizontal, kCTFontVerticalOrientation CT_ENUM_DEPRECATED(10_5, 10_11, 3_2, 9_0) = kCTFontOrientationVertical&#125;; 12345678typedef CF_ENUM(uint32_t, CTFontFormat) &#123; kCTFontFormatUnrecognized = 0, kCTFontFormatOpenTypePostScript = 1, kCTFontFormatOpenTypeTrueType = 2, kCTFontFormatTrueType = 3, kCTFontFormatPostScript = 4, kCTFontFormatBitmap = 5&#125;; 3.Descriptor Creation123CTFontDescriptorRef CTFontDescriptorCreateWithNameAndSize( CFStringRef name, CGFloat size ) CT_AVAILABLE(10_5, 3_2); 12CTFontDescriptorRef CTFontDescriptorCreateWithAttributes( CFDictionaryRef attributes ) CT_AVAILABLE(10_5, 3_2); 123CTFontDescriptorRef CTFontDescriptorCreateCopyWithAttributes( CTFontDescriptorRef original, CFDictionaryRef attributes ) CT_AVAILABLE(10_5, 3_2); 123CTFontDescriptorRef __nullable CTFontDescriptorCreateCopyWithFamily( CTFontDescriptorRef original, CFStringRef family ) CT_AVAILABLE(10_9, 7_0); 1234CTFontDescriptorRef __nullable CTFontDescriptorCreateCopyWithSymbolicTraits( CTFontDescriptorRef original, CTFontSymbolicTraits symTraitValue, CTFontSymbolicTraits symTraitMask ) CT_AVAILABLE(10_9, 7_0); 1234CTFontDescriptorRef CTFontDescriptorCreateCopyWithVariation( CTFontDescriptorRef original, CFNumberRef variationIdentifier, CGFloat variationValue ) CT_AVAILABLE(10_5, 3_2); 1234CTFontDescriptorRef CTFontDescriptorCreateCopyWithFeature( CTFontDescriptorRef original, CFNumberRef featureTypeIdentifier, CFNumberRef featureSelectorIdentifier ) CT_AVAILABLE(10_5, 3_2); 123CFArrayRef __nullable CTFontDescriptorCreateMatchingFontDescriptors( CTFontDescriptorRef descriptor, CFSetRef __nullable mandatoryAttributes ) CT_AVAILABLE(10_5, 3_2); 123CTFontDescriptorRef __nullable CTFontDescriptorCreateMatchingFontDescriptor( CTFontDescriptorRef descriptor, CFSetRef __nullable mandatoryAttributes ) CT_AVAILABLE(10_5, 3_2); 123456789101112131415typedef CF_ENUM(uint32_t, CTFontDescriptorMatchingState) &#123; kCTFontDescriptorMatchingDidBegin, // called once at the beginning. kCTFontDescriptorMatchingDidFinish, // called once at the end. kCTFontDescriptorMatchingWillBeginQuerying, // called once before talking to the server. Skipped if not necessary. kCTFontDescriptorMatchingStalled, // called when stalled. (e.g. while waiting for server response.) // Downloading and activating are repeated for each descriptor. kCTFontDescriptorMatchingWillBeginDownloading, // Downloading part may be skipped if all the assets are already downloaded kCTFontDescriptorMatchingDownloading, kCTFontDescriptorMatchingDidFinishDownloading, kCTFontDescriptorMatchingDidMatch, // called when font descriptor is matched. kCTFontDescriptorMatchingDidFailWithError // called when an error occurred. (may be called multiple times.)&#125;; keys for progressParameter dictionary key value kCTFontDescriptorMatchingSourceDescriptor kCTFontDescriptorMatchingDescriptors kCTFontDescriptorMatchingResult kCTFontDescriptorMatchingPercentage kCTFontDescriptorMatchingCurrentAssetSize kCTFontDescriptorMatchingTotalDownloadedSize kCTFontDescriptorMatchingTotalAssetSize kCTFontDescriptorMatchingError 1234bool CTFontDescriptorMatchFontDescriptorsWithProgressHandler( CFArrayRef descriptors, CFSetRef __nullable mandatoryAttributes, CTFontDescriptorProgressHandler progressBlock) CT_AVAILABLE(10_9, 6_0); 4.Descriptor Accessors123CFTypeRef __nullable CTFontDescriptorCopyAttribute( CTFontDescriptorRef descriptor, CFStringRef attribute ) CT_AVAILABLE(10_5, 3_2); 1234CFTypeRef __nullable CTFontDescriptorCopyLocalizedAttribute( CTFontDescriptorRef descriptor, CFStringRef attribute, CFStringRef __nullable * __nullable language ) CT_AVAILABLE(10_5, 3_2); CTFontCollection.h1.Collection Types1CFTypeID CTFontCollectionGetTypeID( void ) 12345typedef CFComparisonResult (*CTFontCollectionSortDescriptorsCallback)( CTFontDescriptorRef first, CTFontDescriptorRef second, void *refCon ); 排序用的 2.Collection Matching Options key value 解释 kCTFontCollectionRemoveDuplicatesOption a non-zero value collection过滤相同的 duplicate font descriptors kCTFontCollectionIncludeDisabledFontsOption a non-zero value 匹配禁用字体 kCTFontCollectionDisallowAutoActivationOption a non-zero value 不匹配丢失的字体 3.Collection Creation12CTFontCollectionRef CTFontCollectionCreateFromAvailableFonts( CFDictionaryRef __nullable options ) CT_AVAILABLE(10_5, 3_2); 123CTFontCollectionRef CTFontCollectionCreateWithFontDescriptors( CFArrayRef __nullable queryDescriptors, CFDictionaryRef __nullable options ) CT_AVAILABLE(10_5, 3_2); 1234CTFontCollectionRef CTFontCollectionCreateCopyWithFontDescriptors( CTFontCollectionRef original, CFArrayRef __nullable queryDescriptors, CFDictionaryRef __nullable options ) CT_AVAILABLE(10_5, 3_2); 123CTMutableFontCollectionRef CTFontCollectionCreateMutableCopy( CTFontCollectionRef original ) CT_AVAILABLE_MAC(10_7); mac专用 4.Editing the query descriptors12345678910111213141516CFArrayRef __nullable CTFontCollectionCopyQueryDescriptors( CTFontCollectionRef collection ) CT_AVAILABLE_MAC(10_7); mac 专用 void CTFontCollectionSetQueryDescriptors( CTMutableFontCollectionRef collection, CFArrayRef __nullable descriptors ) CT_AVAILABLE_MAC(10_7); mac 专用 CFArrayRef __nullable CTFontCollectionCopyExclusionDescriptors( CTFontCollectionRef collection ) CT_AVAILABLE_MAC(10_7); mac 专用 void CTFontCollectionSetExclusionDescriptors( CTMutableFontCollectionRef collection, CFArrayRef __nullable descriptors ) CT_AVAILABLE_MAC(10_7); mac 专用 5.Retrieving Matching Descriptors12CFArrayRef __nullable CTFontCollectionCreateMatchingFontDescriptors( CTFontCollectionRef collection ) CT_AVAILABLE(10_5, 3_2); 1234CFArrayRef __nullable CTFontCollectionCreateMatchingFontDescriptorsSortedWithCallback( CTFontCollectionRef collection, CTFontCollectionSortDescriptorsCallback __nullable sortCallback, void * __nullable refCon ) CT_AVAILABLE(10_5, 3_2); 12345678910CFArrayRef __nullable CTFontCollectionCreateMatchingFontDescriptorsWithOptions( CTFontCollectionRef collection, CFDictionaryRef __nullable options ) CT_AVAILABLE_MAC(10_7); mac 专用 CFArrayRef __nullable CTFontCollectionCreateMatchingFontDescriptorsForFamily( CTFontCollectionRef collection, CFStringRef familyName, CFDictionaryRef __nullable options ) CT_AVAILABLE_MAC(10_7); mac 专用 6.Bulk attribute access12345678910111213141516171819typedef CF_OPTIONS(uint32_t, CTFontCollectionCopyOptions) &#123; kCTFontCollectionCopyDefaultOptions = 0, kCTFontCollectionCopyUnique = (1 &lt;&lt; 0), kCTFontCollectionCopyStandardSort = (1 &lt;&lt; 1)&#125; CT_AVAILABLE_MAC(10_7);mac 专用CFArrayRef CTFontCollectionCopyFontAttribute( CTFontCollectionRef collection, CFStringRef attributeName, CTFontCollectionCopyOptions options ) CT_AVAILABLE_MAC(10_7); mac 专用 CFArrayRef CTFontCollectionCopyFontAttributes( CTFontCollectionRef collection, CFSetRef attributeNames, CTFontCollectionCopyOptions options ) CT_AVAILABLE_MAC(10_7); mac 专用 CTFont.h富文本离不开文字，下面我们学下字体Font 字体内容较多，我们从以下方面学下。 1.Font Types1CFTypeID CTFontGetTypeID( void ) 获取font CFTypeID 2.Font Constants kCTFontCopyrightNameKey 版权key kCTFontFamilyNameKey family（家族） key kCTFontSubFamilyNameKey subfamily（子家族）key kCTFontStyleNameKey 字体style key kCTFontUniqueNameKey 独一无二key（value不是真的独一无二，不应该假设唯一） kCTFontFullNameKey 字体全名key kCTFontVersionNameKey 字体版本号key kCTFontPostScriptNameKey 字体补充说明key kCTFontTrademarkNameKey 商标key kCTFontManufacturerNameKey 制造商key kCTFontDesignerNameKey 设计者key kCTFontDescriptionNameKey 字体描述key kCTFontVendorURLNameKey 供应商url key kCTFontLicenseNameKey 许可证key kCTFontLicenseURLNameKey 许可证url key kCTFontSampleTextNameKey 简单text key kCTFontPostScriptCIDNameKey 补充说明CID key 这些key 暂时不知道干嘛用的。 3.Font Creation123456789101112131415161718192021222324252627CTFontRef CTFontCreateWithName( CFStringRef __nullable name, CGFloat size, const CGAffineTransform * __nullable matrix ) name 必须是postScript 字符串 代码 -(void)createAllPostScript&#123; NSArray * postScriptArr = (__bridge NSArray *) CTFontManagerCopyAvailablePostScriptNames(); UIScrollView * view = [[UIScrollView alloc]initWithFrame:self.bounds]; view.contentSize = CGSizeMake(self.bounds.size.width, 30*postScriptArr.count); [self addSubview:view]; [postScriptArr enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; NSString * strName = obj; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, idx*30, self.bounds.size.width, 30)]; UIFont * font = (__bridge UIFont *)CTFontCreateWithName((__bridge CFStringRef)strName, 20, NULL); strName =(__bridge NSString *) CTFontCopyPostScriptName((__bridge CTFontRef)font); label.font = font; label.text = strName; [view addSubview:label]; &#125;]; &#125; 结果： 123456789101112131415161718192021222324252627282930313233343536CTFontRef CTFontCreateWithFontDescriptor( CTFontDescriptorRef descriptor, CGFloat size, const CGAffineTransform * __nullable matrix ) 根据descriptor 创建字体 size 设置0.0 默认是12.0 代码 - (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; [self createAllPostScript]; &#125; return self;&#125;-(void)createAllPostScript&#123; NSArray * postScriptArr = (__bridge NSArray *) CTFontManagerCopyAvailablePostScriptNames(); UIScrollView * view = [[UIScrollView alloc]initWithFrame:self.bounds]; view.contentSize = CGSizeMake(self.bounds.size.width, 30*postScriptArr.count); [self addSubview:view]; [postScriptArr enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; NSString * strName = obj; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, idx*30, self.bounds.size.width, 30)]; CTFontDescriptorRef des = CTFontDescriptorCreateWithNameAndSize((__bridge CFStringRef)strName, 20); UIFont * font = (__bridge UIFont *)CTFontCreateWithFontDescriptor(des, 10, NULL); strName =(__bridge NSString *) CTFontCopyPostScriptName((__bridge CTFontRef)font); label.font = font; label.text = strName; [view addSubview:label]; &#125;];&#125; 效果： 1234567891011CTFontRef CTFontCreateWithNameAndOptions( CFStringRef name, CGFloat size, const CGAffineTransform * __nullable matrix, CTFontOptions options ) 主要是CTFontOptions 没发现有啥区别。 同CTFontRef CTFontCreateWithName( CFStringRef __nullable name, CGFloat size, const CGAffineTransform * __nullable matrix )函数效果一样 1234567891011CTFontRef CTFontCreateWithFontDescriptorAndOptions( CTFontDescriptorRef descriptor, CGFloat size, const CGAffineTransform * __nullable matrix, CTFontOptions options ) 效果同 CTFontRef CTFontCreateWithFontDescriptor( CTFontDescriptorRef descriptor, CGFloat size, const CGAffineTransform * __nullable matrix ) 12345CTFontRef __nullable CTFontCreateUIFontForLanguage( CTFontUIFontType uiType, CGFloat size, CFStringRef __nullable language ) 该函数不会使用 language 不知道怎么来的 123456CTFontRef CTFontCreateCopyWithAttributes( CTFontRef font, CGFloat size, const CGAffineTransform * __nullable matrix, CTFontDescriptorRef __nullable attributes ) 根据font 和 attributes 创建一个新的font CTFontDescriptorRef 属性不知道咋用 1234567CTFontRef __nullable CTFontCreateCopyWithSymbolicTraits( CTFontRef font, CGFloat size, const CGAffineTransform * __nullable matrix, CTFontSymbolicTraits symTraitValue, CTFontSymbolicTraits symTraitMask ) 暂时不研究 123456CTFontRef __nullable CTFontCreateCopyWithFamily( CTFontRef font, CGFloat size, const CGAffineTransform * __nullable matrix, CFStringRef family ) 暂时不研究 4.Font Cascading1234CTFontRef CTFontCreateForString( CTFontRef currentFont, CFStringRef string, CFRange range ) CT_AVAILABLE(10_5, 3_2); 5.Font Accessors123456789101112131415CTFontDescriptorRef CTFontCopyFontDescriptor( CTFontRef font ) 获取font 的 descriptorref -(void)font&#123; UIFont * font = [UIFont systemFontOfSize:24]; CTFontDescriptorRef ref = CTFontCopyFontDescriptor((__bridge CTFontRef) font ); CFDictionaryRef attdic = CTFontDescriptorCopyAttributes(ref); NSLog(@&quot;descriptorref %@&quot;,attdic);&#125; 结果： 2017-03-01 16:09:30.336 CoreTextDemo[43313:1154770] descriptorref &#123; NSCTFontUIUsageAttribute = CTFontRegularUsage; NSFontSizeAttribute = 24;&#125; 1234CFTypeRef __nullable CTFontCopyAttribute( CTFontRef font, CFStringRef attribute ) 这个请求font 的 attribute 属性。 暂时 不清楚font到底有啥属性。 123456789CGFloat CTFontGetSize( CTFontRef font ) CT_AVAILABLE(10_5, 3_2);获取字体的大小UIFont * font = [UIFont systemFontOfSize:24]; CGFloat fontSize = CTFontGetSize( (__bridge CTFontRef) font ); NSLog(@&quot;font size %lf&quot;,fontSize); 结果： 2017-03-01 16:14:29.446 CoreTextDemo[43346:1159004] font size 24.000000 123456789CGAffineTransform CTFontGetMatrix( CTFontRef font ) CT_AVAILABLE(10_5, 3_2);获取 transform CTFontRef font =(__bridge CTFontRef) [UIFont systemFontOfSize:24]; CGAffineTransform transform = CTFontGetMatrix( font ); NSLog(@&quot;font transform %@&quot;,NSStringFromCGAffineTransform(transform)); 结果：2017-03-01 16:16:31.407 CoreTextDemo[43362:1161110] font transform [1, 0, 0, 1, 0, 0] 12345678910CTFontSymbolicTraits CTFontGetSymbolicTraits( CTFontRef font ) CT_AVAILABLE(10_5, 3_2);获取 CTFontSymbolicTraits；代码： CTFontRef font =(__bridge CTFontRef) [UIFont systemFontOfSize:24]; CTFontSymbolicTraits symolictraits = CTFontGetSymbolicTraits(font); NSLog(@&quot;font SymbolicTraits %u&quot; , symolictraits); 结果：2017-03-01 16:19:06.667 CoreTextDemo[43380:1163730] font SymbolicTraits 0 12345678910111213CFDictionaryRef CTFontCopyTraits( CTFontRef font ) CT_AVAILABLE(10_5, 3_2);获取一个Traits 字典代码： CTFontRef font =(__bridge CTFontRef) [UIFont systemFontOfSize:24]; NSDictionary * traitsDic =(__bridge NSDictionary *) CTFontCopyTraits(font); NSLog(@&quot;font traits dic %@&quot;,traitsDic);结果： 2017-03-01 16:22:06.911 CoreTextDemo[43403:1166912] font traits dic &#123; NSCTFontSlantTrait = 0; NSCTFontSymbolicTrait = 16384; NSCTFontUIFontDesignTrait = NSCTFontUIFontDesignDefault; 6.Font Names123456789101112 CFStringRef CTFontCopyPostScriptName( CTFontRef font ) CT_AVAILABLE(10_5, 3_2);获取postScriptName 代码： CTFontRef font =(__bridge CTFontRef) [UIFont systemFontOfSize:24]; NSString * postScriptName =(__bridge NSString *) CTFontCopyPostScriptName( font ) ; NSLog(@&quot;font name postScript %@&quot;,postScriptName); 结果： 2017-03-01 16:27:09.535 CoreTextDemo[43424:1171595] font name postScript .SFUIDisplay 12345678910CFStringRef CTFontCopyFamilyName( CTFontRef font ) CT_AVAILABLE(10_5, 3_2);获取familyName 代码： CTFontRef font =(__bridge CTFontRef) [UIFont systemFontOfSize:24]; NSString * familyName =(__bridge NSString *) CTFontCopyFamilyName( font ); NSLog(@&quot;font name familyName %@&quot;,familyName);结果： 2017-03-01 16:31:58.418 CoreTextDemo[43456:1176085] font name familyName .SF UI Display 12345678910CFStringRef CTFontCopyFullName( CTFontRef font ) CT_AVAILABLE(10_5, 3_2); 获取full的名字 代码： CTFontRef font =(__bridge CTFontRef) [UIFont systemFontOfSize:24]; NSString * fullName =(__bridge NSString *) CTFontCopyFullName( font ); NSLog(@&quot;font name fullName %@&quot;,fullName); 结果： 2017-03-01 16:34:50.587 CoreTextDemo[43474:1179511] font name fullName System Font Regular 123456789CFStringRef CTFontCopyDisplayName( CTFontRef font ) CT_AVAILABLE(10_5, 3_2);获取displayName代码： NSString * displayName =(__bridge NSString *) CTFontCopyDisplayName( font ); NSLog(@&quot;font name displayName %@&quot;,displayName);结果： 2017-03-01 16:37:05.363 CoreTextDemo[43491:1182119] font name displayName System Font 1234CFStringRef __nullable CTFontCopyName( CTFontRef font, CFStringRef nameKey ) CT_AVAILABLE(10_5, 3_2); 没看懂干嘛的 12345CFStringRef __nullable CTFontCopyLocalizedName( CTFontRef font, CFStringRef nameKey, CFStringRef __nullable * __nullable actualLanguage ) CT_AVAILABLE(10_5, 3_2);没看懂干嘛的 7.Font Encoding1234567CFCharacterSetRef CTFontCopyCharacterSet( CTFontRef font ) CT_AVAILABLE(10_5, 3_2);获取一个CFCharcerSetRef代码： CTFontRef font =(__bridge CTFontRef) [UIFont systemFontOfSize:24]; CFCharacterSetRef ref = CTFontCopyCharacterSet( font ) ; 1234567891011CFStringEncoding CTFontGetStringEncoding( CTFontRef font ) CT_AVAILABLE(10_5, 3_2);获取编码代码： CTFontRef font =(__bridge CTFontRef) [UIFont systemFontOfSize:24]; CFStringEncoding encoding = CTFontGetStringEncoding(font); NSLog(@&quot;font encoding %u&quot;,(unsigned int)encoding);结果： 2017-03-01 16:56:38.895 CoreTextDemo[43667:1198531] font encoding 0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120CFArrayRef CTFontCopySupportedLanguages( CTFontRef font ) CT_AVAILABLE(10_5, 3_2);获取字体支持的语言代码： CTFontRef font =(__bridge CTFontRef) [UIFont systemFontOfSize:24]; NSArray * supportLanguages = (__bridge NSArray *) CTFontCopySupportedLanguages( font ) ; NSLog(@&quot;font support languages %@&quot;,supportLanguages);结果： font support languages ( wae, hsb, yo, rof, af, dav, be, zu, ca, bg, ce, da, jmc, de, ksb, br, bs, mer, cs, ga, gsw, kde, el, gd, fi, en, ksh, eo, cy, es, fo, et, eu, gl, id, fr, ig, kam, fil, vun, fy, xog, gv, hr, mgh, rwk, lb, hu, fur, ki, seh, is, kk, it, bem, nb, mg, nd, mk, nyn, asa, kw, mn, sbp, lt, ky, nl, lv, nn, ms, mt, teo, guz, om, pl, bez, os, kln, mfe, pt, sg, rm, rn, ro, sk, dsb, tg, qu, sl, luo, ebu, sn, cgg, so, sah, tk, ru, sq, sr, rw, ast, uk, sv, tr, vi, sw, kea, luy, saq) 123456789101112131415161718192021222324252627282930313233343536bool CTFontGetGlyphsForCharacters( CTFontRef font, const UniChar characters[], CGGlyph glyphs[], CFIndex count ) CT_AVAILABLE(10_5, 3_2);用来判断是字符编码是否是fong中的代码：- (BOOL)isCharacter:(unichar*)characters supportedByFont:(UIFont *)aFont length:(NSInteger)length&#123; CGGlyph glyphs[length] ; CTFontRef ctFont = CTFontCreateWithName((CFStringRef)aFont.fontName, aFont.pointSize, NULL); BOOL ret = CTFontGetGlyphsForCharacters(ctFont, characters, glyphs, length); CFRelease(ctFont); return ret;&#125;-(void)font&#123;CTFontRef font =(__bridge CTFontRef) [UIFont systemFontOfSize:24]; NSString *characters = @&quot;a&quot;; unichar * chars = (unichar*)[characters cStringUsingEncoding:NSUTF8StringEncoding]; bool isSuccess=[self isCharacter:chars supportedByFont:[UIFont systemFontOfSize:24] length:characters.length]; if (isSuccess) &#123; NSLog(@&quot;characters success&quot;); &#125;else&#123; NSLog(@&quot;characters failure&quot;); &#125; &#125; 结果： 2017-03-01 17:15:34.008 CoreTextDemo[43765:1215312] characters success 要是为 characters = @&quot;🐯&quot; ； 结果就是 characters failure 目前实验只是针对一个字符好使，多个不好使。 中文字也不行。具体用法还要再探究。 8.Font Metrics123456CGFloat CTFontGetAscent( CTFontRef font ) CT_AVAILABLE(10_5, 3_2);获取 ascentCGFloat CTFontGetDescent( CTFontRef font ) CT_AVAILABLE(10_5, 3_2);获取descentCGFloat CTFontGetLeading( CTFontRef font ) CT_AVAILABLE(10_5, 3_2);获取leading 1unsigned CTFontGetUnitsPerEm( CTFontRef font ) CT_AVAILABLE(10_5, 3_2); 12345678CFIndex CTFontGetGlyphCount( CTFontRef font ) CT_AVAILABLE(10_5, 3_2);获取字体总个数。 CTFontRef font =(__bridge CTFontRef) [UIFont systemFontOfSize:24]; CFIndex index = CTFontGetGlyphCount(font); NSLog(@&quot;font glyph count %ld&quot;,index);结果： 2017-03-01 17:45:17.390 CoreTextDemo[44046:1239054] font glyph count 2325 123456789CGRect CTFontGetBoundingBox( CTFontRef font ) CT_AVAILABLE(10_5, 3_2);获取font 设计大小 CTFontRef font =(__bridge CTFontRef) [UIFont systemFontOfSize:24]; CGRect fontRect = CTFontGetBoundingBox( font ); NSLog(@&quot;font rect %@&quot;,NSStringFromCGRect(fontRect)); 结果：2017-03-01 17:47:19.898 CoreTextDemo[44063:1241783] font rect &#123;&#123;-6.38671875, -6.5390625&#125;, &#123;36.43359375, 32.49609375&#125;&#125; 1234567891011CGFloat CTFontGetUnderlinePosition( CTFontRef font ) CT_AVAILABLE(10_5, 3_2);获取下划线位置 CTFontRef font =(__bridge CTFontRef) [UIFont systemFontOfSize:24]; CGFloat UnderlinePosition = CTFontGetUnderlinePosition( font ); NSLog(@&quot;font UnderlinePosition %lf&quot;,UnderlinePosition); 结果：2017-03-01 19:22:12.226 CoreTextDemo[47842:1272227] font UnderlinePosition -3.632812 123456789101112CGFloat CTFontGetUnderlineThickness( CTFontRef font ) CT_AVAILABLE(10_5, 3_2);获取下划线厚度代码： CTFontRef font =(__bridge CTFontRef) [UIFont systemFontOfSize:24]; CGFloat UnderlineThickness = CTFontGetUnderlineThickness(font); NSLog(@&quot;font UnderlineThickness %lf&quot;,UnderlineThickness); 结果2017-03-01 19:24:51.013 CoreTextDemo[47865:1275126] font UnderlineThickness 1.406250 1234567891011CGFloat CTFontGetSlantAngle( CTFontRef font ) CT_AVAILABLE(10_5, 3_2);获取字体的倾斜角度代码： CTFontRef font =(__bridge CTFontRef) [UIFont systemFontOfSize:24]; CGFloat slantAngle = CTFontGetSlantAngle(font); NSLog(@&quot;font slantAngle %lf&quot;,slantAngle);结果：2017-03-01 19:27:27.999 CoreTextDemo[47890:1278289] font slantAngle 0.000000 12345678910111213CGFloat CTFontGetCapHeight( CTFontRef font ) CT_AVAILABLE(10_5, 3_2);获取cap 高度代码： CTFontRef font =(__bridge CTFontRef) [UIFont systemFontOfSize:24]; CGFloat capHeight = CTFontGetCapHeight(font); NSLog(@&quot;font capHeight %lf&quot;,capHeight); 结果：2017-03-01 19:30:31.542 CoreTextDemo[49032:1283158] font capHeight 16.910156我感觉像是大写字母的高度 123456789101112CGFloat CTFontGetXHeight( CTFontRef font ) CT_AVAILABLE(10_5, 3_2);获取XHeight 高度 小写字母的高度代码： CTFontRef font =(__bridge CTFontRef) [UIFont systemFontOfSize:24]; CGFloat xHeight = CTFontGetXHeight(font); NSLog(@&quot;font xHeight %lf&quot;,xHeight ); 结果：2017-03-01 19:39:33.683 CoreTextDemo[49097:1293600] font xHeight 12.632812 9.Font Glyphs12345678910111213141516CGGlyph CTFontGetGlyphWithName( CTFontRef font, CFStringRef glyphName ) CT_AVAILABLE(10_5, 3_2); 获取一个字形 代码 CTFontRef font =(__bridge CTFontRef) [UIFont systemFontOfSize:24]; NSString * str = @&quot;a&quot;; CGGlyph glyph = CTFontGetGlyphWithName(font,(__bridge CFStringRef)str); NSLog(@&quot;font glyph 查询字符的 cgglyph %d&quot;,glyph); 结果： enable_private_data: 02017-03-01 19:48:52.196 CoreTextDemo[49149:1302956] font glyph 查询字符的 cgglyph 0该函数不会用 123456CGRect CTFontGetBoundingRectsForGlyphs( CTFontRef font, CTFontOrientation orientation, const CGGlyph glyphs[], CGRect * __nullable boundingRects, CFIndex count ) CT_AVAILABLE(10_5, 3_2); 123456CGRect CTFontGetOpticalBoundsForGlyphs( CTFontRef font, const CGGlyph glyphs[], CGRect * __nullable boundingRects, CFIndex count, CFOptionFlags options ) CT_AVAILABLE(10_8, 6_0) 123456double CTFontGetAdvancesForGlyphs( CTFontRef font, CTFontOrientation orientation, const CGGlyph glyphs[], CGSize * __nullable advances, CFIndex count ) CT_AVAILABLE(10_5, 3_2); 12345void CTFontGetVerticalTranslationsForGlyphs( CTFontRef font, const CGGlyph glyphs[], CGSize translations[], CFIndex count ) CT_AVAILABLE(10_5, 3_2); 123456CGPathRef __nullable CTFontCreatePathForGlyph( CTFontRef font, CGGlyph glyph, const CGAffineTransform * __nullable matrix ) CT_AVAILABLE(10_5, 3_2); 暂时不做研究 10.Font Variations key value 解释 kCTFontVariationAxisIdentifierKey CFNumberRef axis identifier kCTFontVariationAxisMinimumValueKey CFNumberRef minimum axis kCTFontVariationAxisMaximumValueKey CFNumberRef maximum axis kCTFontVariationAxisDefaultValueKey CFNumberRef default axis kCTFontVariationAxisNameKey CFNumberRef the localized variation axis name. 1234567891011121314151617181920CFArrayRef __nullable CTFontCopyVariationAxes( CTFontRef font ) CT_AVAILABLE(10_5, 3_2)具体干嘛用的不知道代码： CTFontRef font =(__bridge CTFontRef) [UIFont systemFontOfSize:24]; NSArray * axisArr =(__bridge NSArray *) CTFontCopyVariationAxes(font); NSLog(@&quot;font axis Arr %@&quot;,axisArr);结果：2017-03-02 10:26:35.298 CoreTextDemo[50287:1355486] font axis Arr ( &#123; NSCTVariationAxisMaximumValue = 1.9989, NSCTVariationAxisMinimumValue = 0, NSCTVariationAxisIdentifier = 2003265652, NSCTVariationAxisDefaultValue = 1, NSCTVariationAxisName = Weight, &#125;) 12345678910111213141516CFDictionaryRef __nullable CTFontCopyVariation( CTFontRef font ) CT_AVAILABLE(10_5, 3_2);代码： CTFontRef font =(__bridge CTFontRef) [UIFont systemFontOfSize:24]; NSDictionary * axesdic = (__bridge NSDictionary *)CTFontCopyVariationAxes(font); NSLog(@&quot;font axes dic %@&quot;,axesdic);结果：2017-03-02 10:30:01.138 CoreTextDemo[50305:1358978] font axes dic ( &#123; NSCTVariationAxisMaximumValue = 1.9989, NSCTVariationAxisMinimumValue = 0, NSCTVariationAxisIdentifier = 2003265652, NSCTVariationAxisDefaultValue = 1, NSCTVariationAxisName = Weight, &#125;) 11.Font Features key value 描述 kCTFontOpenTypeFeatureTag CFStringRef kCTFontOpenTypeFeatureValue CFNumberRef kCTFontFeatureTypeIdentifierKey CFNumberRef kCTFontFeatureTypeNameKey CFString kCTFontFeatureTypeExclusiveKey CFBoolean kCTFontFeatureTypeSelectorsKey CFArrayRef kCTFontFeatureSelectorIdentifierKey CFNumberRef kCTFontFeatureSelectorNameKey CFStringRef kCTFontFeatureSelectorDefaultKey CFBooleanRef kCTFontFeatureSelectorSettingKey CFBooleanRef 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200CFArrayRef __nullable CTFontCopyFeatures( CTFontRef font ) CT_AVAILABLE(10_5, 3_2);代码： CTFontRef font =(__bridge CTFontRef) [UIFont systemFontOfSize:24]; NSArray * fontFeatures = (__bridge NSArray *)CTFontCopyFeatures(font); NSLog(@&quot;font Features %@&quot;,fontFeatures);结果：( &#123; CTFeatureTypeIdentifier = 0; CTFeatureTypeName = &quot;All Typographic Features&quot;; CTFeatureTypeNameID = &quot;-100&quot;; CTFeatureTypeSelectors = ( &#123; CTFeatureSelectorDefault = 1; CTFeatureSelectorIdentifier = 0; CTFeatureSelectorName = On; CTFeatureSelectorNameID = &quot;-101&quot;; &#125; ); &#125;, &#123; CTFeatureTypeIdentifier = 1; CTFeatureTypeName = Ligatures; CTFeatureTypeNameID = &quot;-200&quot;; CTFeatureTypeSelectors = ( &#123; CTFeatureSelectorDefault = 1; CTFeatureSelectorIdentifier = 2; CTFeatureSelectorName = &quot;Common Ligatures&quot;; CTFeatureSelectorNameID = &quot;-203&quot;; &#125; ); &#125;, &#123; CTFeatureTypeExclusive = 1; CTFeatureTypeIdentifier = 6; CTFeatureTypeName = &quot;Number Spacing&quot;; CTFeatureTypeNameID = &quot;-700&quot;; CTFeatureTypeSelectors = ( &#123; CTFeatureSelectorIdentifier = 0; CTFeatureSelectorName = &quot;Monospaced Numbers&quot;; CTFeatureSelectorNameID = &quot;-701&quot;; &#125;, &#123; CTFeatureSelectorIdentifier = 1; CTFeatureSelectorName = &quot;Proportional Numbers&quot;; CTFeatureSelectorNameID = &quot;-702&quot;; &#125;, &#123; CTFeatureSelectorDefault = 1; CTFeatureSelectorIdentifier = 4; CTFeatureSelectorName = &quot;No Change&quot;; CTFeatureSelectorNameID = &quot;-705&quot;; &#125; ); &#125;, &#123; CTFeatureTypeExclusive = 1; CTFeatureTypeIdentifier = 10; CTFeatureTypeName = &quot;Vertical Position&quot;; CTFeatureTypeNameID = &quot;-1100&quot;; CTFeatureTypeSelectors = ( &#123; CTFeatureSelectorDefault = 1; CTFeatureSelectorIdentifier = 0; CTFeatureSelectorName = &quot;Normal Vertical Position&quot;; CTFeatureSelectorNameID = &quot;-1101&quot;; &#125;, &#123; CTFeatureSelectorIdentifier = 1; CTFeatureSelectorName = &quot;Superiors/Superscripts&quot;; CTFeatureSelectorNameID = &quot;-1102&quot;; &#125;, &#123; CTFeatureSelectorIdentifier = 2; CTFeatureSelectorName = &quot;Inferiors/Subscripts&quot;; CTFeatureSelectorNameID = &quot;-1103&quot;; &#125; ); &#125;, &#123; CTFeatureTypeExclusive = 1; CTFeatureTypeIdentifier = 11; CTFeatureTypeName = &quot;Contextual Fractional Forms&quot;; CTFeatureTypeNameID = &quot;-1200&quot;; CTFeatureTypeSelectors = ( &#123; CTFeatureSelectorDefault = 1; CTFeatureSelectorIdentifier = 0; CTFeatureSelectorName = &quot;No Fractional Forms&quot;; CTFeatureSelectorNameID = &quot;-1201&quot;; &#125;, &#123; CTFeatureSelectorIdentifier = 2; CTFeatureSelectorName = Diagonal; CTFeatureSelectorNameID = &quot;-1203&quot;; &#125; ); &#125;, &#123; CTFeatureTypeIdentifier = 33; CTFeatureTypeName = &quot;Case-Sensitive Layout&quot;; CTFeatureTypeNameID = &quot;-3400&quot;; CTFeatureTypeSelectors = ( &#123; CTFeatureSelectorIdentifier = 0; CTFeatureSelectorName = &quot;Capital Forms&quot;; CTFeatureSelectorNameID = &quot;-3401&quot;; &#125; ); &#125;, &#123; CTFeatureTypeIdentifier = 35; CTFeatureTypeName = &quot;Alternative Stylistic Sets&quot;; CTFeatureTypeNameID = &quot;-3600&quot;; CTFeatureTypeSelectors = ( &#123; CTFeatureSelectorIdentifier = 2; CTFeatureSelectorName = &quot;Straight-sided six and nine&quot;; CTFeatureSelectorNameID = 256; &#125;, &#123; CTFeatureSelectorIdentifier = 4; CTFeatureSelectorName = &quot;Open four&quot;; CTFeatureSelectorNameID = 257; &#125;, &#123; CTFeatureSelectorIdentifier = 6; CTFeatureSelectorName = &quot;Vertically centered colon&quot;; CTFeatureSelectorNameID = 258; &#125;, &#123; CTFeatureSelectorIdentifier = 12; CTFeatureSelectorName = &quot;High legibility&quot;; CTFeatureSelectorNameID = 259; &#125;, &#123; CTFeatureSelectorIdentifier = 14; CTFeatureSelectorName = &quot;One storey a&quot;; CTFeatureSelectorNameID = 260; &#125; ); &#125;, &#123; CTFeatureTypeIdentifier = 36; CTFeatureTypeName = &quot;Contextual Alternates&quot;; CTFeatureTypeNameID = &quot;-3700&quot;; CTFeatureTypeSelectors = ( &#123; CTFeatureSelectorDefault = 1; CTFeatureSelectorIdentifier = 0; CTFeatureSelectorName = &quot;Contextual Alternates&quot;; CTFeatureSelectorNameID = &quot;-3701&quot;; &#125; ); &#125;, &#123; CTFeatureTypeExclusive = 1; CTFeatureTypeIdentifier = 37; CTFeatureTypeName = &quot;Lower Case&quot;; CTFeatureTypeNameID = &quot;-3800&quot;; CTFeatureTypeSelectors = ( &#123; CTFeatureSelectorDefault = 1; CTFeatureSelectorIdentifier = 0; CTFeatureSelectorName = &quot;No Change&quot;; CTFeatureSelectorNameID = &quot;-3801&quot;; &#125;, &#123; CTFeatureSelectorIdentifier = 1; CTFeatureSelectorName = &quot;Small Capitals&quot;; CTFeatureSelectorNameID = &quot;-3802&quot;; &#125; ); &#125;, &#123; CTFeatureTypeExclusive = 1; CTFeatureTypeIdentifier = 38; CTFeatureTypeName = &quot;Upper Case&quot;; CTFeatureTypeNameID = &quot;-3900&quot;; CTFeatureTypeSelectors = ( &#123; CTFeatureSelectorDefault = 1; CTFeatureSelectorIdentifier = 0; CTFeatureSelectorName = &quot;No Change&quot;; CTFeatureSelectorNameID = &quot;-3901&quot;; &#125;, &#123; CTFeatureSelectorIdentifier = 1; CTFeatureSelectorName = &quot;Small Capitals&quot;; CTFeatureSelectorNameID = &quot;-3902&quot;; &#125; ); &#125;) 123456789CFArrayRef __nullable CTFontCopyFeatureSettings( CTFontRef font ) CT_AVAILABLE(10_5, 3_2);代码： CTFontRef font =(__bridge CTFontRef) [UIFont systemFontOfSize:24]; NSArray * fontSettingsFeatre =(__bridge NSArray * ) CTFontCopyFeatureSettings(font); NSLog(@&quot;font features settings %@&quot;,fontSettingsFeatre); 结果：2017-03-02 10:44:46.354 CoreTextDemo[50763:1374128] font features settings (null) 12.Font Conversion12345CGFontRef CTFontCopyGraphicsFont( CTFontRef font, CTFontDescriptorRef __nullable * __nullable attributes ) CT_AVAILABLE(10_5, 3_2); 讲CTfontRef 转换成CGFontRef 123456CTFontRef CTFontCreateWithGraphicsFont( CGFontRef graphicsFont, CGFloat size, const CGAffineTransform * __nullable matrix, CTFontDescriptorRef __nullable attributes ) CT_AVAILABLE(10_5, 3_2); 将CGfontRef 转换成CTFontRef 1234ATSFontRef CTFontGetPlatformFont( CTFontRef font, CTFontDescriptorRef __nullable * __nullable attributes ) CT_AVAILABLE_MAC(10_5); 12345CTFontRef __nullable CTFontCreateWithPlatformFont( ATSFontRef platformFont, CGFloat size, const CGAffineTransform * __nullable matrix, CTFontDescriptorRef __nullable attributes ) CT_AVAILABLE_MAC(10_5); 12345CTFontRef CTFontCreateWithQuickdrawInstance( ConstStr255Param __nullable name, int16_t identifier, uint8_t style, CGFloat size ) CT_AVAILABLE_MAC(10_5); 13.Font Tables123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263enum &#123; kCTFontTableBASE = &apos;BASE&apos;, // Baseline kCTFontTableCFF = &apos;CFF &apos;, // PostScript font program kCTFontTableDSIG = &apos;DSIG&apos;, // Digital signature kCTFontTableEBDT = &apos;EBDT&apos;, // Embedded bitmap kCTFontTableEBLC = &apos;EBLC&apos;, // Embedded bitmap location kCTFontTableEBSC = &apos;EBSC&apos;, // Embedded bitmap scaling kCTFontTableGDEF = &apos;GDEF&apos;, // Glyph definition kCTFontTableGPOS = &apos;GPOS&apos;, // Glyph positioning kCTFontTableGSUB = &apos;GSUB&apos;, // Glyph substitution kCTFontTableJSTF = &apos;JSTF&apos;, // Justification kCTFontTableLTSH = &apos;LTSH&apos;, // Linear threshold kCTFontTableMATH = &apos;MATH&apos;, // Math kCTFontTableOS2 = &apos;OS/2&apos;, // OS/2 and Windows specific metrics kCTFontTablePCLT = &apos;PCLT&apos;, // PCL 5 data kCTFontTableVDMX = &apos;VDMX&apos;, // Vertical device metrics kCTFontTableVORG = &apos;VORG&apos;, // Vertical origin kCTFontTableZapf = &apos;Zapf&apos;, // Glyph reference kCTFontTableAcnt = &apos;acnt&apos;, // Accent attachment kCTFontTableAnkr = &apos;ankr&apos;, // Anchor points kCTFontTableAvar = &apos;avar&apos;, // Axis variation kCTFontTableBdat = &apos;bdat&apos;, // Bitmap data kCTFontTableBhed = &apos;bhed&apos;, // Bitmap font header kCTFontTableBloc = &apos;bloc&apos;, // Bitmap location kCTFontTableBsln = &apos;bsln&apos;, // Baseline kCTFontTableCmap = &apos;cmap&apos;, // Character to glyph mapping kCTFontTableCvar = &apos;cvar&apos;, // CVT variation kCTFontTableCvt = &apos;cvt &apos;, // Control value table kCTFontTableFdsc = &apos;fdsc&apos;, // Font descriptor kCTFontTableFeat = &apos;feat&apos;, // Layout feature kCTFontTableFmtx = &apos;fmtx&apos;, // Font metrics kCTFontTableFpgm = &apos;fpgm&apos;, // Font program kCTFontTableFvar = &apos;fvar&apos;, // Font variation kCTFontTableGasp = &apos;gasp&apos;, // Grid-fitting/Scan-conversion kCTFontTableGlyf = &apos;glyf&apos;, // Glyph data kCTFontTableGvar = &apos;gvar&apos;, // Glyph variation kCTFontTableHdmx = &apos;hdmx&apos;, // Horizontal device metrics kCTFontTableHead = &apos;head&apos;, // Font header kCTFontTableHhea = &apos;hhea&apos;, // Horizontal header kCTFontTableHmtx = &apos;hmtx&apos;, // Horizontal metrics kCTFontTableHsty = &apos;hsty&apos;, // Horizontal style kCTFontTableJust = &apos;just&apos;, // Justification kCTFontTableKern = &apos;kern&apos;, // Kerning kCTFontTableKerx = &apos;kerx&apos;, // Extended kerning kCTFontTableLcar = &apos;lcar&apos;, // Ligature caret kCTFontTableLtag = &apos;ltag&apos;, // Language tags kCTFontTableLoca = &apos;loca&apos;, // Index to location kCTFontTableMaxp = &apos;maxp&apos;, // Maximum profile kCTFontTableMort = &apos;mort&apos;, // Morph kCTFontTableMorx = &apos;morx&apos;, // Extended morph kCTFontTableName = &apos;name&apos;, // Naming table kCTFontTableOpbd = &apos;opbd&apos;, // Optical bounds kCTFontTablePost = &apos;post&apos;, // PostScript information kCTFontTablePrep = &apos;prep&apos;, // CVT program kCTFontTableProp = &apos;prop&apos;, // Properties kCTFontTableSbit = &apos;sbit&apos;, // Bitmap data kCTFontTableSbix = &apos;sbix&apos;, // Extended bitmap data kCTFontTableTrak = &apos;trak&apos;, // Tracking kCTFontTableVhea = &apos;vhea&apos;, // Vertical header kCTFontTableVmtx = &apos;vmtx&apos; // Vertical metrics&#125;;typedef FourCharCode CTFontTableTag; 1234typedef CF_OPTIONS(uint32_t, CTFontTableOptions) &#123; kCTFontTableOptionNoOptions CT_ENUM_AVAILABLE(10_5, 3_2) = 0, kCTFontTableOptionExcludeSynthetic CT_ENUM_DEPRECATED(10_5, 10_8, 3_2, 6_0) = (1 &lt;&lt; 0)&#125;; 12345CFArrayRef __nullable CTFontCopyAvailableTables( CTFontRef font, CTFontTableOptions options ) CT_AVAILABLE(10_5, 3_2); 运行崩溃 1234CFDataRef __nullable CTFontCopyTable( CTFontRef font, CTFontTableTag table, CTFontTableOptions options ) CT_AVAILABLE(10_5, 3_2); 123456void CTFontDrawGlyphs( CTFontRef font, const CGGlyph glyphs[], const CGPoint positions[], size_t count, CGContextRef context ) CT_AVAILABLE(10_7, 4_2); 12345CFIndex CTFontGetLigatureCaretPositions( CTFontRef font, CGGlyph glyph, CGFloat * __nullable positions, CFIndex maxPositions ) CT_AVAILABLE(10_5, 3_2); 14.Baseline Alignment key value 描述 kCTBaselineClassRoman CFNumberRef kCTBaselineClassIdeographicCentered CFNumberRef kCTBaselineClassIdeographicLow CFNumberRef kCTBaselineClassIdeographicHigh CFNumberRef kCTBaselineClassHanging CFNumberRef kCTBaselineClassMath CFNumberRef kCTBaselineReferenceFont CTFontRef kCTBaselineOriginalFont 12CFArrayRef __nullable CTFontCopyDefaultCascadeListForLanguages( CTFontRef font, CFArrayRef __nullable languagePrefList ) CTGlyphInfo.hCTParagraphStyle.hCTTextTab.hCTRunDelegate.hCTRubyAnnotation.hSFNTLayoutTypes.hSFNTTypes.h###","tags":[]},{"title":"目前常用第三方插件","date":"2015-08-18T06:23:43.000Z","path":"2015/08/18/2015-08-18-mu-qian-chang-yong-di-san-fang-cha-jian/","text":"目前我在用的开发插件 1、xcode生成规范注释 VVDocumenter-Xcode github地址 我改了几行源码就成上面的样子了.代码 安装出现问题可以参考这里 安装VVDocumenter-Xcode ，Xcode 6之后，重启Xcode时会提示“Load bundle”、 “Skip Bundle”，这里必须选择“Load bundle”，不然插件无法使用。但skip是你不小心点击“Skip Bundle” 你可以执行下面命令 defaults delete com.apple.dt.Xcode DVTPlugInManagerNonApplePlugIns-Xcode-{your_xcode_version} 清除你的错误选择 我的xcode是6.4 命令为 defaults delete com.apple.dt.Xcode DVTPlugInManagerNonApplePlugIns-Xcode-6.4 2、生成gif图的工具 licecap 这个工具是免费的 网上搜下到处都是就不提供链接了。","tags":[]},{"title":"更改xcode生成每个文件头信息","date":"2015-08-18T02:13:11.000Z","path":"2015/08/18/2015-08-18-geng-gai-xcodesheng-cheng-mei-ge-wen-jian-tou-xin-xi/","text":"修改xocde文件 的头信息 点击工程文件 点击右边的文件设置窗口 配置project Document 选项中的相关信息 上图第四步 class Prefix 是配置文件头，生成每个类前的头 organization 是配置文件中的 科技 位置的字","tags":[]},{"title":"AVFoundation.framework的学习","date":"2015-08-17T09:15:52.000Z","path":"2015/08/17/2015-08-17-avfoundation-dot-fromworkde-xue-xi/","text":"最近学习自定义相机的相关知识，可以自定义相机成功，但是对AVFoundation不是很了解，这里有必要对这个AVFoundation.framework。 （感觉写点东西咋这么困难） ##学习类对象 AVCaptureSession、AVCaptureInput 和 AVCaptureOutput 的学习 AVCaptureInput is an abstract base-class describing an input data source to an AVCaptureSession object. AVCaptureOutput is an abstract base class describing an output destination of an AVCaptureSession object You use an AVCaptureSession object to coordinate the flow of data from AV input devices to outputs #####参考连接苹果AVFoundation ref 苹果AVFoundation Programming Guide","tags":[]},{"title":"自定义相机","date":"2015-08-12T03:31:08.000Z","path":"2015/08/12/2015-08-12-zi-ding-yi-xiang-ji/","text":"##调用系统相机 调用系统相机一般的功能是可以满足的，如果没有特殊的要求要求，可以直接用系统相机。 代码如下： 调用照相机 if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]) { UIImagePickerController * picker = [[UIImagePickerController alloc]init]; picker.delegate = self; block(picker); //摄像头 picker.sourceType = UIImagePickerControllerSourceTypeCamera; [self presentViewController:picker animated:YES completion:^{ }]; }else{ UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;Error&quot; message:@&quot;你没有摄像头&quot; delegate:nil cancelButtonTitle:@&quot;Drat!&quot; otherButtonTitles:nil]; [alert show]; } 获取图片或者取消图片实现代理 - (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info { UIImage * image = [info objectForKey:UIImagePickerControllerOriginalImage]; if ([self respondsToSelector:@selector(getCameraImage:)]) { [self getCameraImage:image]; } [self dismissViewControllerAnimated:YES completion:^{ }]; } - (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker { [self dismissViewControllerAnimated:YES completion:^{ }]; } 以上代码只是简单的调用下系统相机。并没有对相机进行相关设置。 配置前 注意将系统相机配置成中文 ，在工程文件plist 中添加下面一项即可。 配置后 ##自定义相机 我个人偏向用自定义相机，个人理由只有一条，可以高度定制。（虽然有点麻烦） 暂时更新到这里（哈哈。没有上下文了。）我发现学习相机还是先系统学习学习avfoudation.framework 比较靠谱些。学完av 再回来学喽 #####参考连接","tags":[]},{"title":"进军二维码，从零开始学习二维码","date":"2015-08-11T10:30:03.000Z","path":"2015/08/11/2015-08-11-jin-jun-er-wei-ma-,cong-ling-kai-shi-xue-xi-er-wei-ma/","text":"做项目挺久的了，但是二维码这块总是用别人写好的，自己从来没有操过刀，内心有点小不爽啊，今天索性就写个博客，自己给自己定定需要，学学学习二维码。 二维条码/二维码（2-dimensional bar code）是用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的；在代码编制上巧妙地利用构成计算机内部逻辑基础的“0”、“1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图象输入设备或光电扫描设备自动识读以实现信息自动处理：它具有条码技术的一些共性：每种码制有其特定的字符集；每个字符占有一定的宽度；具有一定的校验功能等。同时还具有对不同行的信息自动识别功能、及处理图形旋转变化点。 二维码扫描现在都是2015年了。就不研究ZBar和ZXing了。今天要介绍的是iOS7.0后AVFoundation框架提供的原生二维码扫描。 二维码生成#####参考链接 二维码百度百科","tags":[]},{"title":"CGAffineTransform.h类的学习和原理讲解","date":"2015-08-10T07:25:44.000Z","path":"2015/08/10/2015-08-10-cgaffinetransform-dot-hlei-de-xue-xi-he-yuan-li-jiang-jie/","text":"第一次写ios相关技术博客，所以先写个简单的，写的不好大家多多提意见。 想学好这个类，我感觉最好还是从理论上弄明白什么二维图形到底是怎么变换的。 矩阵及其运算 一．数学概念定义1.1 由个数 排成m行n列的数表 称为m行n列的矩阵，简称 矩阵，记作 二．原理，公式和法则 1．矩阵的加法(1) 公式 (2) 运算律 2．数乘矩阵 (1) 公式 (2) 运算律 3．矩阵与矩阵相乘 (1) 设 , 则 其中 ，且 （2） 运算符(假设运算都是可行的)： (3) 方阵的运算 注意：①矩阵乘法一般不满足交换律。②一般 4.矩阵的转置(1) 公式 (2) 运算律 5.方阵的行列式 6.共轭矩阵 上面一定要看懂矩阵的乘法是怎么运算的才行。 数学原理 1、基本几何变换及变换矩阵 基本几何变换都是相对于坐标原点和坐标轴进行的几何变换，有平移、比例、旋转、反射和错切等 1.1 平移变换 是指将p点沿直线路径从一个坐标位置移到另一个坐标位置的重定位过程。他是一种不产生变形而移动物体的刚体变换（rigid-body transformation），如下图所示。 推导： 解释(个人理解) x&apos;=x+Tx 相当于x&apos;= x*1 + y*0 + 1 * Tx y&apos;=y+Ty 相当于y&apos;= x*0 + y*1 + 1 * Ty 所以 A 矩阵 [x y 1] C 矩阵要和A矩阵格式一样 [x&apos; y&apos; 1] c矩阵的1 怎么来。只能添加一行了 1=x*0+y*0+ 1*1 所以b矩阵为 上面如图 1.2 缩放变换缩放变换是指对p点相对于坐标原点沿x方向放缩Sx倍，沿y方向放缩Sy倍。其中Sx和Sy称为缩放系数。 推导： 矩阵 x&apos;=x*Sx+y*0 + 0*0; y&apos;=x*0 +y *Sy+0*0; 0=x*0+y*0+0*1; 缩放变换可改变物体的大小，如下图所示。当Sx=Sy &gt;1时，图形沿两个坐标轴方向等比例放大；当Sx=Sy&lt;1，图形沿两个坐标轴方向等比例缩小；当Sx≠Sy，图形沿两个坐标轴方向作非均匀的比例变换。 1.3 旋转变换 二维旋转是指将p点绕坐标原点转动某个角度（逆时针为正，顺时针为负）得到新的点p’的重定位过程。 推导：利用极坐标方程 逆时针旋转θ角的矩阵如下： 1.4 对称变换 对称变换后的图形是原图形关于某一轴线或原点的镜像。 (1)关于x轴对称 x&apos;=x*1+y*0+0*0; y&apos;=x*0+y*(-1)+0*0; 0=x*0+y*0+0*1; (2)关于y轴对称 (3)关于原点对称 (4)关于y=x轴对称 (5)关于y=-x轴对称 1.5 错切变换 错切变换也称为剪切、错位变换，用于产生弹性物体的变形处理。 错切变换的变换矩阵为： (1)沿x方向错切：b=0 (2)沿y方向错切：c=0 (3)两个方向错切：b和c都不等于0。 2、 复合变换 如果图形要做一次以上的几何变换，那么可以将各个变换矩阵综合起来进行一步到位的变换。复合变换有如下的性质： 1）复合平移 对同一图形做两次平移相当于将两次的平移两加起来： 2）复合缩放 两次连续的缩放相当于将缩放操作相乘： 3）复合旋转 两次连续的旋转相当于将两次的旋转角度相加： 缩放、旋转变换都与参考点有关，上面进行的各种变换都是以原点为参考点的。如果相对某个一般的参考点（xf，yf）作缩放、旋转变换，相当于将该点移到坐标原点处，然后进行缩放、旋转变换，最后将（xf，yf）点移回原来的位置。 4）关于（xf，yf）点的缩放变换 5）绕（xf，yf）点的旋转变换 3、二维图形几何变换的计算 几何变换均可表示成P’=P*T的形式 (1)点的变换：先将点表示为规范化齐次坐标形式，再乘以变换矩阵。 (2)直线的变换：将直线的两个端点表示为规范化齐次坐标形式，再乘以变换矩阵。 (3)多边形的变换：将多边形的顶点表示为规范化齐次坐标形式，再乘以变换矩阵。 (4)曲线的变换：将曲线的每个点表示为规范化齐次坐标形式，再乘以变换矩阵。 4、复合变换的矩阵点乘的先后问题 1)如果采用以下方式计算几何变换的变换矩阵 如上范例所示，其先执行变换的矩阵放在前面，后执行变换的矩阵放在后面。 2)如果采用以下方式计算几何变换的变换矩阵： 如上范例所示，其先执行变换的矩阵放在后面，后执行变换的矩阵放在前面。 这是因为矩阵的特性： ##CGAffineTransform.h 函数介绍 说了半天，不来点代码怎么行。 在CGAffineTransform.h 文件中 typedef struct CGAffineTransform CGAffineTransform; struct CGAffineTransform { CGFloat a, b, c, d; CGFloat tx, ty; }; 矩阵数学模型是[a b] c d tx ty 省略了 [a b 0] 中的最后一列 c d 0 tx ty 1 函数介绍代码 ///获取一个标准矩阵。没有变化的矩阵 CGAffineTransform transform= CGAffineTransformIdentity; NSLog(@&quot;CGAffineTransformIdentity 数值%@&quot; , NSStringFromCGAffineTransform(transform)); ///获取一个变幻矩阵 这个函数可以平移旋转和缩放 /* Return the transform [ a b c d tx ty ]. */ transform= CGAffineTransformMake(a, b, c, d,x,y); ///获取一个只做平移的矩阵 // t&apos; = [ 1 0 0 1 tx ty ] transform= CGAffineTransformMakeTranslation(x, y); ///获取一个缩放矩阵 // t&apos; = [ sx 0 0 sy 0 0 ] transform= CGAffineTransformMakeScale(a,c); //获取一个旋转矩阵 /* Return a transform which rotates by `angle&apos; radians: t&apos; = [ cos(angle) sin(angle) -sin(angle) cos(angle) 0 0 ] */ transform= CGAffineTransformMakeRotation(3); ///验证是否是标准矩阵 BOOL isTrue = CGAffineTransformIsIdentity(transform); ///这个是矩阵之间的换算了 /* Translate `t&apos; by `(tx, ty)&apos; and return the result: t&apos; = [ 1 0 0 1 tx ty ] * t */ /// 说的很明确 用只有平移的矩阵和 t 矩阵相乘 t*t&apos; 意思是在t&apos;的基础上做t 变幻（例如平移旋转等等） transform= CGAffineTransformTranslate(transform,x,y); ///矩阵先缩放再transform /* Scale `t&apos; by `(sx, sy)&apos; and return the result: t&apos; = [ sx 0 0 sy 0 0 ] * t */ transform= CGAffineTransformScale(transform,a,c); ///矩阵先旋转再transform /* Rotate `t&apos; by `angle&apos; radians and return the result: t&apos; = [ cos(angle) sin(angle) -sin(angle) cos(angle) 0 0 ] * t */ transform = CGAffineTransformRotate(transform,3); NSLog(@&quot;CGAffineTransformInvert前 数值%@&quot; , NSStringFromCGAffineTransform(transform)); /// 获取 反转矩阵 看不出效果。做图看看 可以仔细研究下 ///我看着就是沿着y轴做了一个对称变换 （不见得对） transform = CGAffineTransformInvert(transform); NSLog(@&quot;CGAffineTransformInvert后 数值%@&quot; , NSStringFromCGAffineTransform(transform)); ///矩阵相乘 /* Concatenate `t2&apos; to `t1&apos; and return the result: t&apos; = t1 * t2 */ transform = CGAffineTransformConcat(transform,transform); ///判断两个矩阵是否相等 /* Return true if `t1&apos; and `t2&apos; are equal, false otherwise. */ isTrue =CGAffineTransformEqualToTransform(transform,transform); ///获取一个点矩阵变幻另一个点的位置 /* Transform `point&apos; by `t&apos; and return the result: p&apos; = p * t where p = [ x y 1 ]. */ CGPoint point= CGPointApplyAffineTransform(CGPointMake(30, 30), transform); ///获取一个矩形矩形变换的大小 /* Transform `size&apos; by `t&apos; and return the result: s&apos; = s * t where s = [ width height 0 ]. */ CGSize size= CGSizeApplyAffineTransform(CGSizeMake(30, 30),transform); ///获取矩形位置变幻后的位置 CGRect rect=CGRectApplyAffineTransform(CGRectMake(0, 0, 30, 30),transform); 项目中有每个函数的具体用法。 项目托管在github #####参考文章：矩阵定义 变换原理 苹果官方文档","tags":[]},{"title":"记录unix命令的使用","date":"2015-08-04T10:07:24.000Z","path":"2015/08/04/2015-08-04-ji-lu-unixming-ling-de-shi-yong/","text":"经常为在mac 终端操作，所以不得不学习一些终端命令并做下记录，方便以后查询。 ##命令查询其实所有的命令参数都是可以通过man 来查询的。 eg： man cd man rm man ls man open 都有命令的详细使用情况 ##命令介绍 rm -rf xxx 删除文件夹xxx（包括里面的内容） mkdir xxx 新建xxx文件夹 cd xxx 进入xxx文件夹，xxx可以是个路径 open . 使用Finder打开当前目录 open ./source 使用Finder打开当前目录下的source文件夹 ls 查看当面文件夹中的目录列表 cd .. 返回上已目录 rm xxx 删除文件 vi xxx 打开文件 进入vi文件之后，q键是功能切换a键是插入操作 shift+q 进入退出模式。wq 写入并保存 q! 强制退出不保存","tags":[]},{"title":"GitPages + Octopress搭建博客（转）","date":"2015-08-04T08:39:04.000Z","path":"2015/08/04/2015-08-04-gitpages-plus-octopressda-jian-bo-ke-(zhuan-)/","text":"#直接转兄弟的链接 GitPages + Octopress 搭建博客 ##我在创建中遇到的问题 主要问题是输入命令rake deploy 的时候报下面的错误 ## Pushing generated _deploy website To git@github.com:NPOpenSource/npopensource.github.com.git ! [rejected] master -&gt; master (non-fast-forward) error: failed to push some refs to &apos;git@github.com:NPOpenSource/ npopensource.github.com.git&apos; hint: Updates were rejected because the tip of your current branch is behind hint: its remote counterpart. Integrate the remote changes (e.g. hint: &apos;git pull ...&apos;) before pushing again. hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 这个原因的产生是因为在目录 /octopress/_deploy/ 下面的文件和远程有冲突导致的。 解决办法是 在 /octopress 输入命令git pull origin master cd _deploy/进入该文件夹 git remote -v查看当前文件下 有冲突的文件 将有冲突的文件解决掉就行了 并提交 保证 git status 结果为 On branch master nothing to commit, working directory clean 之后cd .. 退出到 /octopress 查看 git remote -v 将修改的文件也提交 保证 git status 结果为 On branch master nothing to commit, working directory clean 最后再次运行 rake deploy 就行了。 个性化设置参考链接","tags":[]},{"title":"git的学习使用","date":"2015-08-04T08:33:09.000Z","path":"2015/08/04/2015-08-04-gitde-xue-xi-shi-yong/","text":"##git原理(最好自己实践敲下代码) 底层命令 (Plumbing) 和高层命令 (Porcelain) 用github 不得不学习下 git 命令行。 要想学好git ，我认为，首先要弄懂git 原理，接着熟练掌握git 命令行。 本文讲解了使用 checkout, branch, remote 等共约 30 个 Git 命令。然而由于 Git 一开始被设计成供 VCS 使用的工具集而不是一整套用户友好的 VCS，它还包含了许多底层命令，这些命令用于以 UNIX 风格使用或由脚本调用。这些命令一般被称为 “plumbing” 命令（底层命令），其他的更友好的命令则被称为 “porcelain” 命令（高层命令）。 当你在一个新目录或已有目录内执行 git init 时，Git 会创建一个 .git 目录，几乎所有 Git 存储和操作的内容都位于该目录下。如果你要备份或复制一个库，基本上将这一目录拷贝至其他地方就可以了。本章基本上都讨论该目录下的内容。该目录结构如下： $ ls HEAD branches/ config description hooks/ index info/ objects/ refs/ 该目录下有可能还有其他文件，但这是一个全新的 git init 生成的库，所以默认情况下这些就是你能看到的结构。新版本的 Git 不再使用branches 目录，description 文件仅供 GitWeb 程序使用，所以不用关心这些内容。config 文件包含了项目特有的配置选项，info 目录保存了一份不希望在 .gitignore 文件中管理的忽略模式 (ignored patterns) 的全局可执行文件。hooks 。 另外还有四个重要的文件或目录：HEAD 及 index 文件，objects 及refs 目录。这些是 Git 的核心部分。objects 目录存储所有数据内容，refs 目录存储指向数据 (分支) 的提交对象的指针，HEAD 文件指向当前分支，index 文件保存了暂存区域信息。 Git 对象 Git 是一套内容寻址文件系统。这种说法的意思是，从内部来看，Git 是简单的 key-value 数据存储。它允许插入任意类型的内容，并会返回一个键值，通过该键值可以在任何时候再取出该内容。可以通过底层命令hash-object 来示范这点，传一些数据给该命令，它会将数据保存在 .git 目录并返回表示这些数据的键值。首先初使化一个 Git 仓库并确认objects 目录是空的： $ mkdir test $ cd test $ git init Initialized empty Git repository in /tmp/test/.git/ $ find .git/objects .git/objects .git/objects/info .git/objects/pack $ find .git/objects -type f Git 初始化了 objects 目录，同时在该目录下创建了 pack 和 info 子目录，但是该目录下没有其他常规文件。我们往这个 Git 数据库里存储一些文本： $ echo &apos;test content&apos; | git hash-object -w --stdin d670460b4b4aece5915caf5c68d12f560a9fe3e4 参数 -w 指示 hash-object 命令存储 (数据) 对象，若不指定这个参数该命令仅仅返回键值。–stdin 指定从标准输入设备 (stdin) 来读取内容，若不指定这个参数则需指定一个要存储的文件的路径。该命令输出长度为 40 个字符的校验和。这是个 SHA-1 哈希值──其值为要存储的数据加上你马上会了解到的一种头信息的校验和。现在可以查看到 Git 已经存储了数据 $ find .git/objects -type f .git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 可以在 objects 目录下看到一个文件。这便是 Git 存储数据内容的方式──为每份内容生成一个文件，取得该内容与头信息的 SHA-1 校验和，创建以该校验和前两个字符为名称的子目录，并以 (校验和) 剩下 38 个字符为文件命名 (保存至子目录下)。 通过 cat-file 命令可以将数据内容取回。该命令是查看 Git 对象的瑞士军刀。传入 -p 参数可以让该命令输出数据内容的类型 $ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4 test content 可以往 Git 中添加更多内容并取回了。也可以直接添加文件。比方说可以对一个文件进行简单的版本控制。首先，创建一个新文件，并把文件内容存储到数据库中： $ echo &apos;version 1&apos; &gt; test.txt $ git hash-object -w test.txt 83baae61804e65cc73a7201a7252750c76066a30 接着往该文件中写入一些新内容并再次保存 $ echo &apos;version 2&apos; &gt; test.txt $ git hash-object -w test.txt 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a 数据库中已经将文件的两个新版本连同一开始的内容保存下来了： $ find .git/objects -type f .git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a .git/objects/83/baae61804e65cc73a7201a7252750c76066a30 .git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 再将文件恢复到第一个版本 $ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt $ cat test.txt version 1 或恢复到第二个版本： $ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a &gt; test.txt $ cat test.txt version 2 需要记住的是几个版本的文件 SHA-1 值可能与实际的值不同，其次，存储的并不是文件名而仅仅是文件内容。这种对象类型称为 blob 。通过传递 SHA-1 值给cat-file -t 命令可以让 Git 返回任何对象的类型： $ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a blob tree (树) 对象 接下去来看 tree 对象，tree 对象可以存储文件名，同时也允许存储一组文件。Git 以一种类似 UNIX 文件系统但更简单的方式来存储内容。所有内容以 tree 或 blob 对象存储，其中 tree 对象对应于 UNIX 中的目录，blob 对象则大致对应于 inodes 或文件内容。一个单独的 tree 对象包含一条或多条 tree 记录，每一条记录含有一个指向 blob 或子 tree 对象的 SHA-1 指针，并附有该对象的权限模式 (mode)、类型和文件名信息。以 simplegit 项目为例，最新的 tree 可能是这个样子： $ git cat-file -p master^{tree} 100644 blob a906cb2a4a904a152e80877d4088654daad0c859 README 100644 blob 8f94139338f9404f26296befa88755fc2598c289 Rakefile 040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0 lib 具体生成办法往下看，这个代码可以暂时不验证 master^{tree} 表示 branch 分支上最新提交指向的 tree 对象。请注意 lib 子目录并非一个 blob 对象，而是一个指向别一个 tree 对象的指针： $ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0 100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b simplegit.rb 从概念上来讲，Git 保存的数据如图 你可以自己创建 tree 。通常 Git 根据你的暂存区域或 index 来创建并写入一个 tree 。因此要创建一个 tree 对象的话首先要通过将一些文件暂存从而创建一个 index 。可以使用 plumbing 命令update-index 为一个单独文件 ── test.txt 文件的第一个版本 ── 创建一个 index 。通过该命令人为的将 test.txt 文件的首个版本加入到了一个新的暂存区域中。由于该文件原先并不在暂存区域中 (甚至就连暂存区域也还没被创建出来呢) ，必须传入–add 参数;由于要添加的文件并不在当前目录下而是在数据库中，必须传入 –cacheinfo 参数。同时指定了文件模式，SHA-1 值和文件名： $ git update-index --add --cacheinfo 100644 83baae61804e65cc73a7201a7252750c76066a30 test.txt 在本例中，指定了文件模式为 100644，表明这是一个普通文件。其他可用的模式有：100755 表示可执行文件，120000 表示符号链接。文件模式是从常规的 UNIX 文件模式中参考来的，但是没有那么灵活 ── 上述三种模式仅对 Git 中的文件 (blobs) 有效 (虽然也有其他模式用于目录和子模块)。 现在可以用 write-tree 命令将暂存区域的内容写到一个 tree 对象了。无需 -w 参数 ── 如果目标 tree 不存在，调用write-tree 会自动根据 index 状态创建一个 tree 对象。 $ git write-tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579 $ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579 100644 blob 83baae61804e65cc73a7201a7252750c76066a30 test.txt 可以这样验证这确实是一个 tree 对象 $ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579 tree 再根据 test.txt 的第二个版本以及一个新文件创建一个新 tree 对象： $ echo &apos;new file&apos; &gt; new.txt $ git update-index test.txt $ git update-index --add new.txt 这时暂存区域中包含了 test.txt 的新版本及一个新文件 new.txt 。创建 (写) 该 tree 对象 (将暂存区域或 index 状态写入到一个 tree 对象)，然后瞧瞧它的样子 $ git write-tree 0155eb4229851634a0f03eb265b69f5a2d56f341 $ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341 100644 blob fa49b077972391ad58037050f2a75f74e3671e92 new.txt 100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt 请注意该 tree 对象包含了两个文件记录，且 test.txt 的 SHA 值是早先值的 “第二版” (1f7a7a)。来点更有趣的，你将把第一个 tree 对象作为一个子目录加进该 tree 中。可以用read-tree 命令将 tree 对象读到暂存区域中去。在这时，通过传一个 –prefix 参数给 read-tree，将一个已有的 tree 对象作为一个子 tree 读到暂存区域中 $ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579 $ git write-tree 3c4e9cd789d88d8d89c1073707c3585e41b0e614 $ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614 040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579 bak 100644 blob fa49b077972391ad58037050f2a75f74e3671e92 new.txt 100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt 如果从刚写入的新 tree 对象创建一个工作目录，将得到位于工作目录顶级的两个文件和一个名为 bak 的子目录，该子目录包含了 test.txt 文件的第一个版本。可以将 Git 用来包含这些内容的数据想象成如图 所示的样子 commit (提交) 对象 你现在有三个 tree 对象，它们指向了你要跟踪的项目的不同快照，可是先前的问题依然存在：必须记往三个 SHA-1 值以获得这些快照。你也没有关于谁、何时以及为何保存了这些快照的信息。commit 对象为你保存了这些基本信息。 要创建一个 commit 对象，使用 commit-tree 命令，指定一个 tree 的 SHA-1，如果有任何前继提交对象，也可以指定。从你写的第一个 tree 开始： $ echo &apos;first commit&apos; | git commit-tree d8329f fdf4fc3344e67ab068f836878b6c4951e3b15f3d 通过 cat-file 查看这个新 commit 对象 $ git cat-file -p fdf4fc3 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579 author Scott Chacon 1243040974 -0700 committer Scott Chacon 1243040974 -0700 first commit commit 对象有格式很简单：指明了该时间点项目快照的顶层树对象、作者/提交者信息（从 Git 设理发店的 user.name 和user.email中获得)以及当前时间戳、一个空行，以及提交注释信息。 接着再写入另外两个 commit 对象，每一个都指定其之前的那个 commit 对象 $ echo &apos;second commit&apos; | git commit-tree 0155eb -p fdf4fc3 cac0cab538b970a37ea1e769cbbde608743bc96d $ echo &apos;third commit&apos; | git commit-tree 3c4e9c -p cac0cab 1a410efbd13591db07496601ebc7a059dd55cfe9 每一个 commit 对象都指向了你创建的树对象快照。出乎意料的是，现在已经有了真实的 Git 历史了，所以如果运行 git log 命令并指定最后那个 commit 对象的 SHA-1 便可以查看历史： $ git log --stat 1a410e commit 1a410efbd13591db07496601ebc7a059dd55cfe9 Author: Scott Chacon Date: Fri May 22 18:15:24 2009 -0700 third commit bak/test.txt | 1 + 1 files changed, 1 insertions(+), 0 deletions(-) commit cac0cab538b970a37ea1e769cbbde608743bc96d Author: Scott Chacon Date: Fri May 22 18:14:29 2009 -0700 second commit new.txt | 1 + test.txt | 2 +- 2 files changed, 2 insertions(+), 1 deletions(-) commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d Author: Scott Chacon Date: Fri May 22 18:09:34 2009 -0700 first commit test.txt | 1 + 1 files changed, 1 insertions(+), 0 deletions(-) 真棒。你刚刚通过使用低级操作而不是那些普通命令创建了一个 Git 历史。这基本上就是运行 git add 和 git commit 命令时 Git 进行的工作 ──保存修改了的文件的 blob，更新索引，创建 tree 对象，最后创建 commit 对象，这些 commit 对象指向了顶层 tree 对象以及先前的 commit 对象。这三类 Git 对象 ── blob，tree 以及 tree ── 都各自以文件的方式保存在.git/objects 目录下。以下所列是目前为止样例中的所有对象，每个对象后面的注释里标明了它们保存的内容： $ find .git/objects -type f .git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2 .git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3 .git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2 .git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3 .git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1 .git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2 .git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # &apos;test content&apos; .git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1 .git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt .git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1 如果你按照以上描述进行了操作，可以得到如图所示的对象图 ###原理图 这张图能比较直观的看出git 的工作原理和简单关键命令。 底层命令 (Plumbing) 和高层命令 (Porcelain) 首先要弄明白一点，从根本上来讲 Git 是一套内容寻址 (content-addressable) 文件系统。 ###git 目录 ###关于版本控制（可以不看，讲述git的由来） 本地版本控制系统 许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单。不过坏处也不少：有时候会混淆所在的工作目录，一旦弄错文件丢了数据就没法撤销恢复。 为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。 其中最流行的一种叫做 rcs，现今许多计算机系统上都还看得到它的踪影。甚至在流行的 Mac OS X 系统上安装了开发者工具包之后，也可以使用 rcs 命令。它的工作原理基本上就是保存并管理文件补丁（patch）。文件补丁是一种特定格式的文本文件，记录着对应文件修订前后的内容变化。所以，根据每次 修订后的补丁，rcs 可以通过不断打补丁，计算出各个版本的文件内容。 集中化的版本控制系统 接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？于是，集中化的版本控制系统（ Centralized Version Control Systems，简称 CVCS ）应运而生。这类系统，诸如 CVS，Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这 已成为版本控制系统的标准做法 这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说。现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。 事分两面，有好有坏。这么做最显而易见的缺点是中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。要 是中央服务器的磁盘发生故障，碰巧没做备份，或者备份不够及时，就还是会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录，而被客户端 提取出来的某些快照数据除外，但这样的话依然是个问题，你不能保证所有的数据都已经有人事先完整提取出来过。本地版本控制系统也存在类似问题，只要整个项 目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险 分布式版本控制系统 于是分布式版本控制系统（ Distributed Version Control System，简称 DVCS ）面世了。在这类系统中，像 Git，Mercurial，Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜 像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份。 更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。 ###git基础 直接记录快照，而非差异比较 Git 和其他版本控制系统的主要差别在于，Git 只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异。这类系统 （CVS，Subversion，Perforce，Bazaar 等等）每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容 Git 并不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照 的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。 这是 Git 同其他系统的重要区别。它完全颠覆了传统版本控制的套路，并对各个环节的实现方式作了新的设计。Git 更像是个小型的文件系统，但它同时还提供了许多以此为基础的超强工具，而不只是一个简单的 VCS 近乎所有操作都是本地执行 在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。但如果用 CVCS 的话，差不多所有操作都需要连接网络。因为 Git 在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快。 举个例子，如果要浏览项目的历史更新摘要，Git 不用跑到外面的服务器上去取数据回来，而直接从本地数据库读取后展示给你看。所以任何时候你都可以马上翻阅，无需等待。如果想要看当前版本的文件和一个月 前的版本之间有何差异，Git 会取出一个月前的快照和当前文件作一次差异运算，而不用请求远程服务器来做这件事，或是把老版本的文件拉到本地来作比较。 时刻保持数据完整性 在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。换句话说，不可能在你修改了文件或目录之后，Git 一无所知。这项特性作为 Git 的设计哲学，建在整体架构的最底层。所以如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，Git 都能立即察觉。 Git 使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个 SHA-1 哈希值，作为指纹字符串。该字串由 40 个十六进制字符（0-9 及 a-f）组成，看起来就像是： 24b9da6552252987aa493b52f8696cd6d3b00373 Git 的工作完全依赖于这类指纹字串，所以你会经常看到这样的哈希值。实际上，所有保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。 多数操作仅添加数据 常用的 Git 操作大多仅仅是把数据添加到数据库。因为任何一种不可逆的操作，比如删除数据，都会使回退或重现历史版本变得困难重重。在别的 VCS 中，若还未提交更新，就有可能丢失或者混淆一些修改的内容，但在 Git 里，一旦提交快照之后就完全不用担心丢失数据，特别是养成定期推送到其他仓库的习惯的话。 文件的三种状态 好，现在请注意，接下来要讲的概念非常重要。对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地数据库 中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。 由此我们看到 Git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，以及本地仓库。 每个项目都有一个 Git 目录（译注：如果 git clone 出来的话，就是其中 .git 的目录；如果git clone –bare 的话，新建的目录本身就是 Git 目录。），它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。 从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录。这些文件实际上都是从 Git 目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这些文件进行编辑。 所谓的暂存区域只不过是个简单的文件，一般都放在 Git 目录中。有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。 基本的 Git 工作流程如下： 在工作目录中修改某些文件。 2. 对修改后的文件进行快照，然后保存到暂存区域。 3. 提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。 所以，我们可以从文件所处的位置来判断状态：如果是 Git 目录中保存着的特定版本文件，就属于已提交状态；如果作了修改并已放入暂存区域，就属于已暂存状态；如果自上次取出后，作了修改但还没有放到暂存区域，就 是已修改状态。 请记住，工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记 录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存 区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。 在编辑过某些文件之后，Git 将这些文件标为已修改。我们逐步把这些修改过的文件放到暂存区域，直到最后一次性提交所有这些暂存起来的文件，如此重复。所以使用 Git 时的文件状态变化周期如图 git 分支 何谓分支 为了理解 Git 分支的实现方式，我们需要回顾一下 Git 是如何储存数据的。或许你还记得第一章的内容，Git 保存的不是文件差异或者变化量，而只是一系列文件快照。 在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对 象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。 为直观起见，我们假设在工作目录中有三个文件，准备将它们暂存后提交。暂存操作会对每一个文件计算校验和，然后把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 类型的对象存储这些快照），并将校验和加入暂存区域： $ git add README test.rb LICENSE $ git commit -m &apos;initial commit of my project&apos; 当使用 git commit 新建一个提交对象前，Git 会先计算每一个子目录（本例中就是项目根目录）的校验和，然后在 Git 仓库中将这些目录保存为树（tree）对象。之后 Git 创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此它就可以在将来需要的时候，重现此次快照的内容了。 现在，Git 仓库中有五个对象：三个表示文件快照内容的 blob 对象；一个记录着目录树内容及其中各个文件对应 blob 对象索引的 tree 对象；以及一个包含指向 tree 对象（根目录）的索引和其他提交信息元数据的 commit 对象。概念上来说，仓库中的各个对象保存的数据和相互关系看起来如图： 作些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针（译注：即下图中的 parent 对象）。两次提交后，仓库历史会变成下图 现在来谈分支。Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。Git 会使用 master 作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的 master 分支，它在每次提交的时候都会自动向前移动。 Git 又是如何创建一个新的分支的呢？答案很简单，创建一个新的分支指针。比如新建一个 testing 分支，可以使用 git branch 命令： $ git branch testing 这会在当前 commit 对象上新建一个分支指针如图 那么，Git 是如何知道你当前在哪个分支上工作的呢？其实答案也很简单，它保存着一个名为 HEAD 的特别指针。请注意它和你熟知的许多其他版本控制系统（比如 Subversion 或 CVS）里的 HEAD 概念大不相同。在 Git 中，它是一个指向你正在工作中的本地分支的指针（译注：将 HEAD 想象为当前分支的别名。）。运行git branch 命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，所以在这个例子中，我们依然还在 master 分支里工作(如图) 要切换到其他分支，可以执行 git checkout 命令。我们现在转换到新建的 testing 分支 $ git checkout testing 这样 HEAD 就指向了 testing 分支 这样的实现方式会给我们带来什么好处呢？好吧，现在不妨再提交一次： $ vim test.rb $ git commit -a -m &apos;made a change&apos; 下图 展示了提交后的结果 非常有趣，现在 testing 分支向前移动了一格，而 master 分支仍然指向原先 git checkout 时所在的 commit 对象。现在我们回到 master 分支看看： $ git checkout master 下图 显示了结果。 这条命令做了两件事。它把 HEAD 指针移回到 master 分支，并把工作目录中的文件换成了 master 分支所指向的快照内容。也就是说，现在开始所做的改动，将始于本项目中一个较老的版本。它的主要作用是将 testing 分支里作出的修改暂时取消，这样你就可以向另一个方向进行开发。 我们作些修改后再次提交： $ vim test.rb $ git commit -a -m &apos;made other changes&apos; 现在我们的项目提交历史产生了分叉（如图 3-9 所示），因为刚才我们创建了一个分支，转换到其中进行了一些工作，然后又回到原来的主分支进行了另外一些工作。这些改变分别孤立在不同的分支里：我们可以 在不同分支里反复切换，并在时机成熟时把它们合并到一起。而所有这些工作，仅仅需要branch 和 checkout 这两条命令就可以完成。 由于 Git 中的分支实际上仅是一个包含所指对象校验和（40 个字符长度 SHA-1 字串）的文件，所以创建和销毁一个分支就变得非常廉价。说白了，新建一个分支就是向一个文件写入 41 个字节（外加一个换行符）那么简单，当然也就很快了。 这和大多数版本控制系统形成了鲜明对比，它们管理分支大多采取备份所有项目文件到特定目录的方式，所以根据项目文件数量和大小不同，可能花费的时间 也会有相当大的差别，快则几秒，慢则数分钟。而 Git 的实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。同时，因为每次提交时都记录了祖先信息（译注：即parent 对象），将来要合并分支时，寻找恰当的合并基础（译注：即共同祖先）的工作其实已经自然而然地摆在那里了，所以实现起来非常容易。Git 鼓励开发者频繁使用分支，正是因为有着这些特性作保障 分支的新建与合并 现在让我们来看一个简单的分支与合并的例子，实际工作中大体也会用到这样的工作流程： 开发某个网站。 2. 为实现某个新的需求，创建一个分支。 3. 在这个分支上开展工作。 假设此时，你突然接到一个电话说有个很严重的问题需要紧急修补，那么可以按照下面的方式处理： 返回到原先已经发布到生产服务器上的分支。 2. 为这次紧急修补建立一个新分支，并在其中修复问题。 3. 通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上。 4. 切换到之前实现新需求的分支，继续工作。 分支的新建与切换 首先，我们假设你正在项目中愉快地工作，并且已经提交了几次更新 现在，你决定要修补问题追踪系统上的 #53 问题。顺带说明下，Git 并不同任何特定的问题追踪系统打交道。这里为了说明要解决的问题，才把新建的分支取名为 iss53。要新建并切换到该分支，运行git checkout 并加上 -b 参数： $ git checkout -b iss53 Switched to a new branch &quot;iss53&quot; 这相当于执行下面这两条命令： $ git branch iss53 $ git checkout iss53 图 示意该命令的执行结果。 接着你开始尝试修复问题，在提交了若干次更新后，iss53 分支的指针也会随着向前推进，因为它就是当前分支（换句话说，当前的 HEAD 指针正指向 iss53，见图 ）： $ vim index.html $ git commit -a -m &apos;added a new footer [issue 53]&apos; 现在你就接到了那个网站问题的紧急电话，需要马上修补。有了 Git ，我们就不需要同时发布这个补丁和 iss53 里作出的修改，也不需要在创建和发布该补丁到服务器之前花费大力气来复原这些修改。唯一需要的仅仅是切换回master 分支。 不过在此之前，留心你的暂存区或者工作目录里，那些还没有提交的修改，它会和你即将检出的分支产生冲突从而阻止 Git 为你切换分支。切换分支的时候最好保持一个清洁的工作区域。稍后会介绍几个绕过这种问题的办法（分别叫做 stashing 和 commit amending）。目前已经提交了所有的修改，所以接下来可以正常转换到master 分支： $ git checkout master Switched to branch &quot;master&quot; 此时工作目录中的内容和你在解决问题 #53 之前一模一样，你可以集中精力进行紧急修补。这一点值得牢记：Git 会把工作目录的内容恢复为检出某分支时它所指向的那个提交对象的快照。它会自动添加、删除和修改文件以确保目录的内容和你当时提交时完全一样 接下来，你得进行紧急修补。我们创建一个紧急修补分支 hotfix 来开展工作，直到搞定（见图 3-13）： $ git checkout -b &apos;hotfix&apos; $ vim index.html $ git commit -a -m &apos;fixed &quot; 有必要作些测试，确保修补是成功的，然后回到 master 分支并把它合并进来，然后发布到生产服务器。用 git merge 命令来进行合并 $ git checkout master $ git merge hotfix 请注意，合并时出现了“Fast forward”的提示。由于当前 master 分支所在的提交对象是要并入的 hotfix 分支的直接上游，Git 只需把master 分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。 现在最新的修改已经在当前 master 分支所指向的提交对象中了，可以部署到生产服务器上去了在那个超级重要的修补发布以后，你想要回到被打扰之前的工作。由于当前 hotfix 分支和 master 都指向相同的提交对象，所以hotfix 已经完成了历史使命，可以删掉了。使用 git branch 的 -d 选项执行删除操作： $ git branch -d hotfix Deleted branch hotfix (3a0874c). 现在回到之前未完成的 #53 问题修复分支上继续工作 $ git checkout iss53 $ vim index.html $ git commit -a -m &quot;new content&quot; 不用担心之前 hotfix 分支的修改内容尚未包含到 iss53 中来。如果确实需要纳入此次修补，可以用git merge master 把 master 分支合并到 iss53；或者等 iss53 完成之后，再将iss53 分支中的更新并入 master 分支的合并 在问题 #53 相关的工作完成之后，可以合并回 master 分支。实际操作同前面合并 hotfix 分支差不多，只需回到master 分支，运行 git merge 命令指定要合并进来的分支： $ git checkout master $ git merge iss53 请注意，这次合并操作的底层实现，并不同于之前 hotfix 的并入方式。因为这次你的开发历史是从更早的地方开始分叉的。由于当前 master 分支所指向的提交对象（C4）并不是 iss53 分支的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。图 3-16 用红框标出了 Git 用于合并的三个提交对象 这次，Git 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）（见图）。这个提交对象比较特殊，它有两个祖先（C4 和 C5）。 值得一提的是 Git 可以自己裁决哪个共同祖先才是最佳合并基础；这和 CVS 或 Subversion（1.5 以后的版本）不同，它们需要开发者手工指定合并基础。所以此特性让 Git 的合并操作比其他系统都要简单不少 既然之前的工作成果已经合并到 master 了，那么 iss53 也就没用了。你可以就此删除它，并在问题追踪系统里关闭该问题。 $ git branch -d iss53 遇到冲突时的分支合并 有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（译注：逻辑上说，这种问题只能由人来裁决。）。如果你在解决问题 #53 的过程中修改了hotfix 中修改的部分，将得到类似下面的结果 $ git merge iss53 Auto-merging index.html CONFLICT (content): Merge conflict in index.html Automatic merge failed; fix conflicts and then commit the result. Git 作了合并，但没有提交，它会停下来等你解决冲突。要看看哪些文件在合并时发生冲突，可以用 git status 查阅 [master*]$ git status index.html: needs merge # On branch master # Changed but not updated: # (use &quot;git add ...&quot; to update what will be committed) # (use &quot;git checkout -- ...&quot; to discard changes in working directory) # # unmerged: index.html # 任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。可以看到此文件包含类似下面这样的部分： &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html contact : email.support@github.com ======= please contact us at support@github.com &gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html 可以看到 ======= 隔开的上半部分，是 HEAD（即 master 分支，在运行merge 命令时所切换到的分支）中的内容，下半部分是在 iss53 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决 please contact us at email.support@github.com 这个解决方案各采纳了两个分支中的一部分内容，而且我还删除了 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，======= 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 这些行。在解决了所有文件里的所有冲突后，运行 git add 将把它们标记为已解决状态（译注：实际上就是来一次快照保存到暂存区域。）。因为一旦暂存，就表示冲突已经解决。如果你想用一个有图形界面的工具来解决这些问题，不妨运行git mergetool，它会调用一个可视化的合并工具并引导你解决所有冲突： $ git mergetool merge tool candidates: kdiff3 tkdiff xxdiff meld gvimdiff opendiff emerge vimdiff Merging the files: index.html Normal merge conflict for &apos;index.html&apos;: {local}: modified {remote}: modified Hit return to start merge resolution tool (opendiff): 如果不想用默认的合并工具（Git 为我默认选择了 opendiff，因为我在 Mac 上运行了该命令），你可以在上方”merge tool candidates”里找到可用的合并工具列表，输入你想用的工具名。我们将在第七章讨论怎样改变环境中的默认值。 退出合并工具以后，Git 会询问你合并是否成功。如果回答是，它会为你把相关文件暂存起来，以表明状态为已解决。 再运行一次 git status 来确认所有冲突都已解决： $ git status # On branch master # Changes to be committed: # (use &quot;git reset HEAD ...&quot; to unstage) # # modified: index.html # 如果觉得满意了，并且确认所有冲突都已解决，也就是进入了暂存区，就可以用 git commit 来完成这次合并提交。提交的记录差不多是这样： Merge branch &apos;iss53&apos; Conflicts: index.html # # It looks like you may be committing a MERGE. # If this is not correct, please remove the file # .git/MERGE_HEAD # and try again. # 如果想给将来看这次合并的人一些方便，可以修改该信息，提供更多合并细节。比如你都作了哪些改动，以及这么做的原因。有时候裁决冲突的理由并不直接或明显，有必要略加注解。 分支的管理 到目前为止，你已经学会了如何创建、合并和删除分支。除此之外，我们还需要学习如何管理分支，在日后的常规工作中会经常用到下面介绍的管理命令 git branch 命令不仅仅能创建和删除分支，如果不加任何参数，它会给出当前所有分支的清单 $ git branch iss53 * master testing 注意看 master 分支前的 * 字符：它表示当前所在的分支。也就是说，如果现在提交更新，master 分支将随着开发进度前移。若要查看各个分支最后一个提交对象的信息，运行git branch -v $ git branch -v iss53 93b412c fix javascript issue * master 7a98805 Merge branch &apos;iss53&apos; testing 782fd34 add scott to the author list in the readmes 要从该清单中筛选出你已经（或尚未）与当前分支合并的分支，可以用 –merge 和 –no-merged 选项（Git 1.5.6 以上版本）。比如用git branch –merge 查看哪些分支已被并入当前分支（译注：也就是说哪些分支是当前分支的直接上游。）： $ git branch --merged iss53 * master 之前我们已经合并了 iss53，所以在这里会看到它。一般来说，列表中没有 * 的分支通常都可以用 git branch -d 来删掉。原因很简单，既然已经把它们所包含的工作整合到了其他分支，删掉也不会损失什么。 另外可以用 git branch –no-merged 查看尚未合并的工作： $ git branch --no-merged testing 它会显示还未合并进来的分支。由于这些分支中还包含着尚未合并进来的工作成果，所以简单地用 git branch -d 删除该分支会提示错误，因为那样做会丢失数据 $ git branch -d testing error: The branch &apos;testing&apos; is not an ancestor of your current HEAD. If you are sure you want to delete it, run &apos;git branch -D testing&apos;. 不过，如果你确实想要删除该分支上的改动，可以用大写的删除选项 -D 强制执行，就像上面提示信息中给出的那样。 利用分支进行开发的工作流程 长期分支 由于 Git 使用简单的三方合并，所以就算在较长一段时间内，反复多次把某个分支合并到另一分支，也不是什么难事。也就是说，你可以同时拥有多个开放的分支，每个分支用于完成特定的任务，随着开发的推进，你可以随时把某个特性分支的成果并到其他分支中。 许多使用 Git 的开发者都喜欢用这种方式来开展工作，比如仅在 master 分支中保留完全稳定的代码，即已经发布或即将发布的代码。与此同时，他们还有一个名为develop 或 next 的平行分支，专门用于后续的开发，或仅用于稳定性测试 — 当然并不是说一定要绝对稳定，不过一旦进入某种稳定状态，便可以把它合并到master 里。这样，在确保这些已完成的特性分支（短期分支，比如之前的 iss53 分支）能够通过所有测试，并且不会引入更多错误之后，就可以并到主干分支中，等待下一次的发布 本质上我们刚才谈论的，是随着提交对象不断右移的指针。稳定分支的指针总是在提交历史中落后一大截，而前沿分支总是比较靠前 或者把它们想象成工作流水线，或许更好理解一些，经过测试的提交对象集合被遴选到更稳定的流水线（见图 ）。 你可以用这招维护不同层次的稳定性。某些大项目还会有个 proposed（建议）或 pu（proposed updates，建议更新）分支，它包含着那些可能还没有成熟到进入next 或 master 的内容。这么做的目的是拥有不同层次的稳定性：当这些分支进入到更稳定的水平时，再把它们合并到更高层分支中去。再次说明下，使用多个长期分支的做法并非必需，不过一般来说，对于特大型项目或特复杂的项目，这么做确实更容易管理。 特性分支 在任何规模的项目中都可以使用特性（Topic）分支。一个特性分支是指一个短期的，用来实现单一特性或与其相关工作的分支。可能你在以前的版本控 制系统里从未做过类似这样的事情，因为通常创建与合并分支消耗太大。然而在 Git 中，一天之内建立、使用、合并再删除多个分支是常见的事。 我们在上节的例子里已经见过这种用法了。我们创建了 iss53 和 hotfix 这两个特性分支，在提交了若干更新后，把它们合并到主干分支，然后删除。该技术允许你迅速且完全的进行语境切换 — 因为你的工作分散在不同的流水线里，每个分支里的改变都和它的目标特性相关，浏览代码之类的事情因而变得更简单了。你可以把作出的改变保持在特性分支中几 分钟，几天甚至几个月，等它们成熟以后再合并，而不用在乎它们建立的顺序或者进度。 现在我们来看一个实际的例子。请看图 ，由下往上，起先我们在 master 工作到 C1，然后开始一个新分支 iss91 尝试修复 91 号缺陷，提交到 C6 的时候，又冒出一个解决该问题的新办法，于是从之前 C4 的地方又分出一个分支iss91v2，干到 C8 的时候，又回到主干 master 中提交了 C9 和 C10，再回到 iss91v2 继续工作，提交 C11，接着，又冒出个不太确定的想法，从 master 的最新提交 C10 处开了个新的分支dumbidea 做些试验。 现在，假定两件事情：我们最终决定使用第二个解决方案，即 iss91v2 中的办法；另外，我们把 dumbidea 分支拿给同事们看了以后，发现它竟然是个天才之作。所以接下来，我们准备抛弃原来的iss91 分支（实际上会丢弃 C5 和 C6），直接在主干中并入另外两个分支。最终的提交历史将变成图 这样 请务必牢记这些分支全部都是本地分支，这一点很重要。当你在使用分支及合并的时候，一切都是在你自己的 Git 仓库中进行的 — 完全不涉及与服务器的交互 远程分支 远程分支（remote branch）是对远程仓库中的分支的索引。它们是一些无法移动的本地分支；只有在 Git 进行网络交互时才会更新。远程分支就像是书签，提醒着你上次连接远程仓库时上面各分支的位置。 我们用 (远程仓库名)/(分支名) 这样的形式表示远程分支。比如我们想看看上次同 origin 仓库通讯时master 的样子，就应该查看 origin/master 分支。如果你和同伴一起修复某个问题，但他们先推送了一个iss53 分支到远程仓库，虽然你可能也有一个本地的 iss53 分支，但指向服务器上最新更新的却应该是 origin/iss53 分支。 可能有点乱，我们不妨举例说明。假设你们团队有个地址为 git.ourcompany.com 的 Git 服务器。如果你从这里克隆，Git 会自动为你将此远程仓库命名为origin，并下载其中所有的数据，建立一个指向它的 master 分支的指针，在本地命名为 origin/master，但你无法在本地更改其数据。接着，Git 建立一个属于你自己的本地master 分支，始于 origin 上 master 分支相同的位置，你可以就此开始工作 一次 Git 克隆会建立你自己的本地分支 master 和远程分支 origin/master，它们都指向 origin/master 分支的最后一次提交。 如果你在本地 master 分支做了些改动，与此同时，其他人向 git.ourcompany.com 推送了他们的更新，那么服务器上的master 分支就会向前推进，而于此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的 origin/master 指针仍然保持原位不会移动 可以运行 git fetch origin 来同步远程服务器上的数据到本地。该命令首先找到 origin 是哪个服务器（本例为git.ourcompany.com），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把 origin/master 的指针移到它最新的位置上 git fetch 命令会更新 remote 索引 为了演示拥有多个远程分支（在不同的远程服务器上）的项目是如何工作的，我们假设你还有另一个仅供你的敏捷开发小组使用的内部服务器 git.team1.ourcompany.com。可以用第二章中提到的git remote add 命令把它加为当前项目的远程分支之一。我们把它命名为 teamone，以便代替原始的 Git 地址 把另一个服务器加为远程仓库 现在你可以用 git fetch teamone 来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你 origin 服务器上的子集，Git 不会下载任何数据，而只是简单地创建一个名为teamone/master 的分支，指向 teamone 服务器上 master 分支所在的提交对象31b8e 你在本地有了一个指向 teamone 服务器上 master 分支的索引。 推送本地分支 要想和其他人分享某个本地分支，你需要把它推送到一个你拥有写权限的远程仓库。你的本地分支不会被自动同步到你引入的远程服务器上，除非你明确执行推送操作。换句话说，对于无意分享的分支，你尽管保留为私人分支好了，而只推送那些协同工作要用到的特性分支。 如果你有个叫 serverfix 的分支需要和他人一起开发，可以运行 git push (远程仓库名) (分支名) $ git push origin serverfix Counting objects: 20, done. Compressing objects: 100% (14/14), done. Writing objects: 100% (15/15), 1.74 KiB, done. Total 15 (delta 5), reused 0 (delta 0) To git@github.com:schacon/simplegit.git * [new branch] serverfix -&gt; serverfix 其实有点像条捷径。Git 自动把 serverfix 分支名扩展为 refs/heads/serverfix:refs/heads/serverfix，意为“取出我在本地的 serverfix 分支，推送到远程仓库的 serverfix 分支中去”。我们将在第九章进一步介绍refs/heads/ 部分的细节，不过一般使用的时候都可以省略它。也可以运行 git push origin serverfix:serferfix 来实现相同的效果，它的意思是“上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作awesomebranch，可以用 git push origin serverfix:awesomebranch 来推送数据。 接下来，当你的协作者再次从服务器上获取数据时，他们将得到一个新的远程分支 origin/serverfix $ git fetch origin remote: Counting objects: 20, done. remote: Compressing objects: 100% (14/14), done. remote: Total 15 (delta 5), reused 0 (delta 0) Unpacking objects: 100% (15/15), done. From git@github.com:schacon/simplegit * [new branch] serverfix -&gt; origin/serverfix 值得注意的是，在 fetch 操作下载好新的远程分支之后，你仍然无法在本地编辑该远程仓库中的分支。换句话说，在本例中，你不会有一个新的serverfix 分支，有的只是一个你无法移动的 origin/serverfix 指针。 如果要把该内容合并到当前分支，可以运行 git merge origin/serverfix。如果想要一份自己的 serverfix 来开发，可以在远程分支的基础上分化出一个新的分支来： $ git checkout -b serverfix origin/serverfix Branch serverfix set up to track remote branch refs/remotes/origin/serverfix. Switched to a new branch “serverfix” 这会切换到新建的 serverfix 本地分支，其内容同远程分支 origin/serverfix 一致，这样你就可以在里面继续开发了。 跟踪远程分支 从远程分支 checkout 出来的本地分支，称为跟踪分支(tracking branch)。跟踪分支是一种和远程分支有直接联系的本地分支。在跟踪分支里输入git push，Git 会自行推断应该向哪个服务器的哪个分支推送数据。反过来，在这些分支里运行 git pull 会获取所有远程索引，并把它们的数据都合并到本地分支中来。 在克隆仓库时，Git 通常会自动创建一个名为 master 的分支来跟踪 origin/master。这正是git push 和 git pull 一开始就能正常工作的原因。当然，你可以随心所欲地设定为其它跟踪分支，比如origin 上除了 master 之外的其它分支。刚才我们已经看到了这样的一个例子：git checkout -b [分支名] [远程名]/[分支名]。如果你有 1.6.2 以上版本的 Git，还可以用–track 选项简化 $ git checkout --track origin/serverfix Branch serverfix set up to track remote branch refs/remotes/origin/serverfix. Switched to a new branch &quot;serverfix&quot; 要为本地分支设定不同于远程分支的名字，只需在前个版本的命令里换个名字： $ git checkout -b sf origin/serverfix Branch sf set up to track remote branch refs/remotes/origin/serverfix. Switched to a new branch &quot;sf&quot; 现在你的本地分支 sf 会自动向 origin/serverfix 推送和抓取数据了。 删除远程分支 如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的 master 分支（或任何其他存放稳定代码的地方），可以用这个非常无厘头的语法来删除它：git push [远程名] :[分支名]。如果想在服务器上删除serverfix 分支，运行下面的命令 $ git push origin :serverfix To git@github.com:schacon/simplegit.git - [deleted] serverfix 咚！服务器上的分支没了。你最好特别留心这一页，因为你一定会用到那个命令，而且你很可能会忘掉它的语法。有种方便记忆这条命令的方法：记住我们不久前见过的 git push [远程名] [本地分支]:[远程分支] 语法，如果省略 [本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]” 分支的衍合 把一个分支整合到另一个分支的办法有两种：merge 和 rebase（译注：rebase 的翻译暂定为“衍合”，大家知道就可以了。）。在本章我们会学习什么是衍合，如何使用衍合，为什么衍合操作如此富有魅力，以及我们应该在什么情况下使用衍合。 基本的衍合操作 请回顾之前有关合并的一节（见图），你会看到开发进程分叉到两个不同分支，又各自提交了更新。 之前介绍过，最容易的整合分支的方法是 merge 命令，它会把两个分支最新的快照（C3 和 C4）以及二者最新的共同祖先（C2）进行三方合并，合并的结果是产生一个新的提交对象（C5） 其实，还有另外一个选择：你可以把在 C3 里产生的变化补丁在 C4 的基础上重新打一遍。在 Git 里，这种操作叫做衍合（rebase）。有了 rebase 命令，就可以把在一个分支里提交的改变移到另一个分支里重放一遍 在上面这个例子中，运行 $ git checkout experiment $ git rebase master First, rewinding head to replay your work on top of it... Applying: added staged command 它的原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支 experiment）后续的历次提交对象（这里只有一个 C3），生成一系列文件补丁，然后以基底分支（也就是主干分支master）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写 experiment 的提交历史，使它成为 master 分支的直接下游， 现在回到 master 分支，进行一次快进合并 现在的 C3’ 对应的快照，其实和普通的三方合并，即上个例子中的 C5 对应的快照内容一模一样了。虽然最后整合得到的结果没有任何区别，但衍合能产生一个更为整洁的提交历史。如果视察一个衍合过的分支的历史记录，看起来会更 清楚：仿佛所有修改都是在一根线上先后进行的，尽管实际上它们原本是同时并行发生的。 一般我们使用衍合的目的，是想要得到一个能在远程分支上干净应用的补丁 — 比如某些项目你不是维护者，但想帮点忙的话，最好用衍合：先在自己的一个分支里进行开发，当准备向主项目提交补丁的时候，根据最新的origin/master 进行一次衍合操作然后再提交，这样维护者就不需要做任何整合工作（译注：实际上是把解决分支补丁同最新主干代码之间冲突的责任，化转为由提交补丁的人来解决。），只需根据你提供的仓库地址作一次快进合并，或者直接采纳你提交的补丁。 请注意，合并结果中最后一次提交所指向的快照，无论是通过衍合，还是三方合并，都会得到相同的快照内容，只不过提交历史不同罢了。衍合是按照每行的修改次序重演一遍修改，而合并是把最终结果合在一起。 有趣的衍合 衍合也可以放到其他分支进行，并不一定非得根据分化之前的分支。下图 ，我们为了给服务器端代码添加一些功能而创建了特性分支 server，然后提交 C3 和 C4。然后又从 C3 的地方再增加一个client 分支来对客户端代码进行一些相应修改，所以提交了 C8 和 C9。最后，又回到 server 分支提交了 C10。 假设在接下来的一次软件发布中，我们决定先把客户端的修改并到主线中，而暂缓并入服务端软件的修改（因为还需要进一步测试）。这个时候，我们就可以把基于 server 分支而非 master 分支的改变（即 C8 和 C9），跳过 server 直接放到master 分支中重演一遍，但这需要用 git rebase 的 –onto 选项指定新的基底分支master： $ git rebase --onto master server client 这好比在说：“取出 client 分支，找出 client 分支和 server 分支的共同祖先之后的变化，然后把它们在master 上重演一遍”。是不是有点复杂？不过它的结果如图 所示，非常酷（译注：虽然 client 里的 C8, C9 在 C3 之后，但这仅表明时间上的先后，而非在 C3 修改的基础上进一步改动，因为server 和 client 这两个分支对应的代码应该是两套文件，虽然这么说不是很严格，但应理解为在 C3 时间点之后，对另外的文件所做的 C8，C9 修改，放到主干重演。 现在可以快进 master 分支了： $ git checkout master $ git merge client 现在我们决定把 server 分支的变化也包含进来。我们可以直接把 server 分支衍合到 master，而不用手工切换到 server 分支后再执行衍合操作 — git rebase [主分支] [特性分支] 命令会先取出特性分支server，然后在主分支 master 上重演 $ git rebase master server 于是，server 的进度应用到 master 的基础上，如图 然后就可以快进主干分支 master 了： $ git checkout master $ git merge server 现在 client 和 server 分支的变化都已经集成到主干分支来了，可以删掉它们了。最终我们的提交历史会变成图 $ git branch -d client $ git branch -d server 衍合的风险 呃，奇妙的衍合也并非完美无缺，要用它得遵守一条准则： 一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。如果你遵循这条金科玉律，就不会出差错。否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。 在进行衍合的时候，实际上抛弃了一些现存的提交对象而创造了一些类似但不同的新的提交对象。如果你把原来分支中的提交对象发布出去，并且其他人更新下载后在其基础上开展工作，而稍后你又用git rebase 抛弃这些提交对象，把新的重演后的提交对象发布出去的话，你的合作者就不得不重新合并他们的工作，这样当你再次从他们那里获取内容时，提交历史就会变得一团糟。 下面我们用一个实际例子来说明为什么公开的衍合会带来问题。假设你从一个中央服务器克隆然后在它的基础上搞了一些开发，提交历史类似图 现在，某人在 C1 的基础上做了些改变，并合并他自己的分支得到结果 C6，推送到中央服务器。当你抓取并合并这些数据到你本地的开发分支中后，会得到合并结果 C7，历史提交会变成图 接下来，那个推送 C6 上来的人决定用衍合取代之前的合并操作；继而又用 git push –force 覆盖了服务器上的历史，得到 C4’。而之后当你再从服务器上下载最新提交后，会得到： 下载更新后需要合并，但此时衍合产生的提交对象 C4’ 的 SHA-1 校验值和之前 C4 完全不同，所以 Git 会把它们当作新的提交对象处理，而实际上此刻你的提交历史 C7 中早已经包含了 C4 的修改内容，于是合并操作会把 C7 和 C4’ 合并为 C8 C8 这一步的合并是迟早会发生的，因为只有这样你才能和其他协作者提交的内容保持同步。而在 C8 之后，你的提交历史里就会同时包含 C4 和 C4’，两者有着不同的 SHA-1 校验值，如果用git log 查看历史，会看到两个提交拥有相同的作者日期与说明，令人费解。而更糟的是，当你把这样的历史推送到服务器后，会再次把这些衍合后的提交引入到中央服务 器，进一步困扰其他人（译注：这个例子中，出问题的责任方是那个发布了 C6 后又用衍合发布 C4’ 的人，其他人会因此反馈双重历史到共享主干，从而混淆大家的视听。）。 如果把衍合当成一种在推送之前清理提交历史的手段，而且仅仅衍合那些尚未公开的提交对象，就没问题。如果衍合那些已经公开的提交对象，并且已经有人基于这些提交对象开展了后续开发工作的话，就会出现叫人沮丧的麻烦。 ###服务器上的git 省略 ###git命令 Git 提供了一个叫做 git config 的工具（译注：实际是 git-config 命令，只不过可以通过 git 加一个名字来呼叫此命令。），专门用来配置或读取相应的工作环境变量。而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方： /etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用--system 选项，读写的就是这个文件。 ~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用--global 选项，读写的就是这个文件。 当前项目的 git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以.git/config 里的配置会覆盖/etc/gitconfig 中的同名变量。 git config –list 要检查已有的配置信息 git config –global user.name “John Doe” 配置用户名 git config –global user.email johndoe@example.com 配置邮件 git config –global core.editor emacs 文本编辑器 git config –global merge.tool vimdiff 配置差异性分析工具（Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。） git config user.name 查看用户名 git help config 查看git config的文档 git –help 查看git使用文档 man git 查看git 文档 git help 查看git使用文档 git init 在工作目录中初始化新仓库（初始化后，在当前目录下会出现一个名为 .git 的目录） git add git add &lt;文件或者文件夹&gt; 可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等）潜台词就是把目标文件快照放入暂存区域） git commit -m ‘initial project version’ 提交文件 git clone git://github.com/schacon/grit.git 克隆文件到当前文件夹 git clone git://github.com/schacon/grit.git mygrit 克隆文件到当前文件夹并将文件夹命名为 myfrit git status 检查当前文件状态 cat .gitignore .[oa] ~ 第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。第二行告诉 Git 忽略所有以波浪符（~）结尾的文件 （可以添加多个忽略文件匹配，之间用空格空开） 12345文件 .gitignore 的格式规范如下：所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。可以使用标准的 glob 模式匹配。 * 匹配模式最后跟反斜杠（/）说明要忽略的是目录。 * 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如[0-9] 表示匹配所有 0 到 9 的数字）。 git diff 查看尚未暂存的文件更新了哪些部分 git diff –cached 已经暂存起来的文件和上次提交时的快照之间的差异 例如 vim read git add read ///这第一个新生产的问题提交到git 缓存区域了 vim read 打开read 输入文字abc git add read ///第二次保存快照 vim read 再次打开read 输入文字efg （现在文字问abcdef） git diff 这时候输出的结果是 diff --git a/README b/README index 40bae04..f74d0d3 100644 --- a/README +++ b/README @@ -1 +1 @@ -abc +abcdef 比较的是未提交的文件与缓存区的文件比较（个人理解） git diff --cached 这时候输出的结果是 diff --git a/README b/README new file mode 100644 index 0000000..40bae04 --- /dev/null +++ b/README @@ -0,0 +1 @@ +abc 比较的是缓存区最后两次的比较 （个人理解） git commit 将暂存文件提交 可以看到，默认的提交消息包含最后一次运行 git status 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。退出编辑器时，Git 会丢掉注释行，将说明内容和本次更新提交到仓库。 git commit -m “提交说明” -m 参数后跟提交说明的方式，在一行命令中提交更新 git commit -a 自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤 git rm 从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 git rm -f 删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母），以防误删除文件后丢失修改的内容 git rm –cached readme.txt 另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆.a 编译文件，不小心纳入仓库后，要移除跟踪但不删除文件，以便稍后在 .gitignore 文件中补上，用 –cached 选项即可 git rm log/*.log 后面可以列出文件或者目录的名字，也可以使用 glob 模式 git mv file_from file_to 移动文件 其实，运行 git mv 就相当于运行了下面三条命令： $ mv README.txt README $ git rm README.txt $ git add README git log 查看提交历史 git log -p -2 -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新 git commit –amend 有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以使用 –amend 选项重新提交（修改提交信息） git reset HEAD benchmarks.rb 取消已经暂存的文件 git checkout – benchmarks.rb 取消对文件的修改 git remote 查看当前的远程库 git remote -v 查看当前的远程库,显示对应的克隆地址 远程操作 git remote add [shortname] [url] 要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用（在我看来，就是和远程仓库建立一个连接，给命名了一个别名。网上说的迷迷糊糊的） git fetch pb 到远程仓库中拉取所有你本地仓库中还没有的数据，运行完成后，你就可以在本地访问该远程仓库中的所有分支 如果是克隆了一个仓库，此命令会自动将远程仓库归于 origin 名下。所以，git fetch origin 会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）。有一点很重要，需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。 如果设置了某个分支用于跟踪某个远端仓库的分支（参见下节及第三章的内容），可以使用 git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。在日常工作中我们经常这么用，既快且好。实际上，默认情况下git clone 命令本质上就是自动创建了本地的 master 分支用于跟踪远程仓库中的 master 分支（假设远程仓库确实有 master 分支）。所以一般我们运行git pull，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。 git push [remote-name] [branch-name] 将本地仓库中的数据推送到远程仓库 要把本地的 master 分支推送到origin 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令： $ git push origin master 只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。如果在你推数据前，已经有其他人推送了若干更新，那 你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。 git remote show [remote-name] 查看某个远程仓库的详细信息 git remote rename [pb] [paul] 对远程仓库的重命名 将pb重命名为paul git remote rm paul 删除paul远端仓库连接 2.6 打标签 (这个我用的不多暂时不弄这个了) git tag 列出现有标签 git tag -a v1.4 -m ‘my version 1.4’ 创建一个含附注类型的标签非常简单，用 -a 而 -m 选项则指定了对应的标签说明 git branch testing 新建一个 testing 分支 git checkout testing 切换testing分支 git checkout -b iss53 新建并切换到iss53分支 git merge hotfix 将hotfix分支merge到当前分支 $ git branch -d iss53 删除分支 git branch 查看分支 git branch -v 若要查看各个分支最后一个提交对象的信息 git branch –merged 筛选出已经与当前分支合并的分支 git branch –no-merged 筛选出已经与当前分支未合并的分支 git checkout –track 跟踪分支 git push [远程名] :[分支名] 删除分支*git rebase master 将分支衍生到master上 ####参考链接： git - 简易指南 git - 原理比较清晰 #####延伸连接 git详解之一 git详解之二 Git详解之三 Git分支 Git详解之四 服务器上的Git Git详解之五 分布式Git Git详解之六 Git工具 Git详解之七 自定义Git Git详解之八 Git与其他系统 Git详解之九 Git内部原理","tags":[]},{"title":"rake在octopress中的使用命令介绍","date":"2015-08-04T08:23:23.000Z","path":"2015/08/04/2015-08-04-rakezai-octopresszhong-de-shi-yong-ming-ling-jie-shao/","text":"刚开始接触octopress ，对rake命令使用的较少，特在此记录，记录每个命令的作用。 ##命令 rake generate 将 /octopress/source/_posts 目录下的 .markdown 文件 翻译成html网页 rake preview 生成本地网页服务器，端口号4000 http://localhost:4000 rake deploy 将本地的_deploy 修改的文件提交到 github上面去。 rake new_post[‘新的博客名字’] 在 octopress/source/_posts 目录下创建博客，名字为《新的博客名字》","tags":[]},{"title":"makedown的简单使用","date":"2015-08-03T03:52:07.000Z","path":"2015/08/03/2015-8-3-markdown/","text":"纪要由于要用markdown写博客并进行排版，所以暂时先简单的学习使用下。 编辑软件 Mou link markdown语言编辑软件. 语法纪要####段落、标题、区块代码 一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，就被视为空行，例如有一行只有空白和 tab，那该行也会被视为空行），一般的段落不需要用空白或换行缩进。 Markdown 支持两种标题的语法，Setext 和 atx 形式。Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），Atx 形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。 区块引用则使用 email 形式的 ‘&gt;’ 角括号 常用语法： 输出后的效果 Markdown 快捷键 是否好用 H1 # Heading H2 ## Heading Ctrl/⌘ + H 不好用 H3 ### Heading Ctrl/⌘ + H (x2) 不好用 Blockquote &gt; quote Ctrl + Q 好用 Markdown 语法: A First Level Header ==================== A Second Level Header --------------------- Now is the time for all good men to come to the aid of their country. This is just a regular paragraph. The quick brown fox jumped over the lazy dog&apos;s back. ### Header 3 &gt; This is a blockquote. &gt; &gt; This is the second paragraph in the blockquote. &gt; &gt; ## This is an H2 in a blockquote 输出 HTML 为： &lt;h1&gt;A First Level Header&lt;/h1&gt; &lt;h2&gt;A Second Level Header&lt;/h2&gt; &lt;p&gt;Now is the time for all good men to come to the aid of their country. This is just a regular paragraph.&lt;/p&gt; &lt;p&gt;The quick brown fox jumped over the lazy dog&apos;s back.&lt;/p&gt; &lt;h3&gt;Header 3&lt;/h3&gt; &lt;blockquote&gt; &lt;p&gt;This is a blockquote.&lt;/p&gt; &lt;p&gt;This is the second paragraph in the blockquote.&lt;/p&gt; &lt;h2&gt;This is an H2 in a blockquote&lt;/h2&gt; &lt;/blockquote&gt; 注释： 如果你在项目之间插入空行，那项目的内容会用 &lt;p&gt; 包起来，你也可以在一个项目内放上多个段落，只要在它前面缩排 4 个空白或 1 个 tab 。 如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 &amp;、&lt; 和 &gt; 也一样会自动转成 HTML 实体 ####修辞和强调 Markdown 使用星号和底线来标记需要强调的区段。 常用语法： 输出后的效果 Markdown 快捷键 是否好用 Bold text ⌘ + B（mac） 好用 Emphasize text ⌘ + I（mac） 好用 Strike-through #text Ctrl + Alt + U 不好用 Blockquote &gt; quote Ctrl + Q Markdown 语法: Some of these words *are emphasized*. Some of these words _are emphasized also_. Use two asterisks for **strong emphasis**. Or, if you prefer, __use two underscores instead__. 输出 HTML 为: &lt;p&gt;Some of these words &lt;em&gt;are emphasized&lt;/em&gt;. Some of these words &lt;em&gt;are emphasized also&lt;/em&gt;.&lt;/p&gt; &lt;p&gt;Use two asterisks for &lt;strong&gt;strong emphasis&lt;/strong&gt;. Or, if you prefer, &lt;strong&gt;use two underscores instead&lt;/strong&gt;.&lt;/p&gt; ####列表无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的. 常用语法： 输出后的效果 Markdown 快捷键 是否好用 List * item Ctrl + L 好用 List + item List - item List 1 item 星号 * Candy. * Gum. * Booze. 加号 + Candy. + Gum. + Booze. 和减号 - Candy. - Gum. - Booze. 都会输出 HTML 为： &lt;ul&gt; &lt;li&gt;Candy.&lt;/li&gt; &lt;li&gt;Gum.&lt;/li&gt; &lt;li&gt;Booze.&lt;/li&gt; &lt;/ul&gt; 有序的列表则是使用一般的数字接着一个英文句点作为项目标记 1. Red 2. Green 3. Blue 输出 HTML 为： &lt;ol&gt; &lt;li&gt;Red&lt;/li&gt; &lt;li&gt;Green&lt;/li&gt; &lt;li&gt;Blue&lt;/li&gt; &lt;/ol&gt; ####链接 Markdown 支援两种形式的链接语法： 行内 和 参考 两种形式，两种都是使用角括号来把文字转成连结。 常用语法 输出后的效果 Markdown 快捷键 Link title 行内形式是直接在后面用括号直接接上链接： This is an [example link](http://example.com/). 输出 HTML 为 &lt;p&gt;This is an &lt;a href=&quot;http://example.com/&quot;&gt;example link&lt;/a&gt;.&lt;/p&gt; 你也可以选择性的加上 title 属性： This is an [example link](http://example.com/ &quot;With a Title&quot;). 输出 HTML 为 &lt;p&gt;This is an &lt;a href=&quot;http://example.com/&quot; title=&quot;With a Title&quot;&gt;example link&lt;/a&gt;.&lt;/p&gt; 参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容： I get 10 times more traffic from [Google][1] than from[Yahoo][2] or [MSN][3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 输出 HTML 为： &lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot;title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from &lt;a href=&quot;http://search.yahoo.com/&quot;title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt; or &lt;a href=&quot;http://search.msn.com/&quot;title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt; title 属性是选择性的，链接名称可以用字母、数字和空格，但是不分大小写： I start my morning with a cup of coffee and [The New York Times][NY Times]. [ny times]: http://www.nytimes.com/ 输出 HTML 为： &lt;p&gt;I start my morning with a cup of coffee and&lt;a href=&quot;http://www.nytimes.com/&quot;&gt;The New York Times&lt;/a&gt;.&lt;/p&gt; ####代码 常用语法 输出后的效果 Markdown 快捷键 是否好用 Inline Code code ⌘ + K 好用 在一般的段落文字中，你可以使用反引号 ` 来标记代码区段，区段内的 &amp;、&lt; 和 &gt; 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码： I strongly recommend against using any `&lt;blink&gt;` tags.I wish SmartyPants used named entities like `&amp;mdash;`instead of decimal-encoded entites like `&amp;#8212;`. 输出 HTML 为： &lt;p&gt;I strongly recommend against using any&lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;&lt;p&gt;I wish SmartyPants used named entities like&lt;code&gt;&amp;amp;mdash;&lt;/code&gt; instead of decimal-encodedentites like &lt;code&gt;&amp;amp;#8212;&lt;/code&gt;.&lt;/p&gt; ###图片 图片的语法和链接很像。 行内形式（title 是选择性的）： ![alt text](/images/email.png &quot;Title&quot;) 结果 参考形式： ![alt text][id] [id]: /images/email.png &quot;Title&quot; 结果 提示：github引用图片资源应该放在octopress/source/images/ tablemarkdown 生成table 可以直接用html标签 相对比较麻烦 （github 不支持表格） &lt;table border=4 width=250 align=center bordercolor=red&gt; &lt;tr&gt; &lt;td&gt;北京 &lt;/td&gt; &lt;td&gt;雾霾 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;深圳 &lt;/td&gt; &lt;td&gt;暴雨 &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 只有width 起作用 响应的效果 北京 雾霾 深圳 暴雨 ####文本样式 链接 :Title 加粗 :Bold 斜体字 :Italics 删除线 :text 高亮 :==text== 段落 : 段落之间空一行 换行符 : 一行结束时输入两个空格 列表 :* 添加星号成为一个新的列表项。 引用 :&gt; 引用内容 内嵌代码 : alert(&#39;Hello World&#39;); 画水平线 (HR) :——– #####参考链接： http://wowubuntu.com/markdown/basic.html markdown百度百科","tags":[]},{"title":"博客的第一天","date":"2015-07-31T03:52:07.000Z","path":"2015/07/31/2015-08-03-博客第一天/","text":"#新的一天新的开始。只有不断的学习不断的积累才能强大自己。加油。","tags":[]}]